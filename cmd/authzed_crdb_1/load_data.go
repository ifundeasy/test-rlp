package authzed_crdb_1

import (
	"context"
	"encoding/csv"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"

	v1 "github.com/authzed/authzed-go/proto/authzed/api/v1"
	authzed "github.com/authzed/authzed-go/v1"

	"test-tls/infrastructure"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

const (
	// We now treat CSV as the single source of truth.
	dataDir   = "data"
	batchSize = 1000 // increased to SpiceDB's maximum for WriteRelationships
)

// AuthzedCreateData loads the deterministic relational ACL dataset generated by
// cmd/csv/load_data.go into SpiceDB, using schemas.zed as the schema.
func AuthzedCreateData() {
	client, _, cancel, err := infrastructure.NewAuthzedCrdbClientFromEnv(context.Background())
	if err != nil {
		log.Fatalf("[authzed_crdb_1] create authzed client: %v", err)
	}
	defer cancel()
	defer client.Close()

	start := time.Now()
	relCount := 0
	batch := make([]*v1.RelationshipUpdate, 0, batchSize)

	log.Printf("[authzed_crdb_1] == Starting Authzed data import from CSV in %q ==", dataDir)

	loadOrgMemberships(client, &batch, &relCount, start)
	loadGroups(client, &batch, &relCount, start)
	loadGroupMemberships(client, &batch, &relCount, start)
	loadResources(client, &batch, &relCount, start)
	loadResourceACL(client, &batch, &relCount, start)

	// Flush remaining batch with token caching
	if len(batch) > 0 {
		writeBatchWithToken(client, batch)
	}

	elapsed := time.Since(start).Truncate(time.Millisecond)
	log.Printf("[authzed_crdb_1] Authzed data import DONE: totalRelationships=%d elapsed=%s", relCount, elapsed)
}

// =========================
// CSV loading helper
// =========================

func openCSV(name string) (*csv.Reader, *os.File) {
	full := filepath.Join(dataDir, name)
	f, err := os.Open(full)
	if err != nil {
		log.Fatalf("[authzed_crdb_1] open %s: %v", full, err)
	}
	r := csv.NewReader(f)
	return r, f
}

// We deliberately keep object IDs equal to the CSV IDs (plain decimal strings)
// for 1:1 mapping across backends. If you ever want prefixes like "user42",
// change these helpers consistently.
func orgObjectID(id string) string      { return id }
func userObjectID(id string) string     { return id }
func groupObjectID(id string) string    { return id }
func resourceObjectID(id string) string { return id }

// =========================
// Phase 1: Organizations & org_memberships.csv
// =========================
//
// org_memberships.csv: org_id,user_id,role
//   - role in {"member","admin"}
//   - maps to organization.admin_user / organization.member_user

func loadOrgMemberships(client *authzed.Client, batch *[]*v1.RelationshipUpdate, relCount *int, start time.Time) {
	r, f := openCSV("org_memberships.csv")
	defer f.Close()

	// Skip header
	if _, err := r.Read(); err != nil {
		log.Fatalf("[authzed_crdb_1] read org_memberships header: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[authzed_crdb_1] read org_memberships row: %v", err)
		}
		if len(rec) < 3 {
			log.Fatalf("[authzed_crdb_1] invalid org_memberships row: %#v", rec)
		}

		orgIDRaw := rec[0]
		userIDRaw := rec[1]
		role := rec[2]

		orgID := orgObjectID(orgIDRaw)
		userID := userObjectID(userIDRaw)

		var relation string
		switch role {
		case "admin":
			relation = "admin_user"
		default:
			// treat anything non-admin as member
			relation = "member_user"
		}

		*batch = append(*batch, mkCreateRel(
			"organization", orgID,
			relation,
			"user", userID,
			"",
		))
		*relCount++
		count++
		flushIfNeeded(client, batch, relCount, start)
	}

	log.Printf("[authzed_crdb_1] Loaded org_memberships: %d relationships (cumulative=%d)", count, *relCount)
}

// =========================
// Phase 2: groups.csv -> organization.member_group
// =========================
//
// groups.csv: group_id,org_id
// We model each group as belonging to its organization via member_group,
// using the usergroup#member userset as per schemas.zed:
//
//   relation member_group: usergroup#member
//
// This makes members of those groups count as organization members via
// organization.permission member.

func loadGroups(client *authzed.Client, batch *[]*v1.RelationshipUpdate, relCount *int, start time.Time) {
	r, f := openCSV("groups.csv")
	defer f.Close()

	// header: group_id,org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[authzed_crdb_1] read groups header: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[authzed_crdb_1] read groups row: %v", err)
		}
		if len(rec) < 2 {
			log.Fatalf("[authzed_crdb_1] invalid groups row: %#v", rec)
		}

		groupIDRaw := rec[0]
		orgIDRaw := rec[1]

		groupID := groupObjectID(groupIDRaw)
		orgID := orgObjectID(orgIDRaw)

		// organization#member_group@usergroup:group#member
		*batch = append(*batch, mkCreateRel(
			"organization", orgID,
			"member_group",
			"usergroup", groupID,
			"member",
		))
		*relCount++
		count++
		flushIfNeeded(client, batch, relCount, start)
	}

	log.Printf("[authzed_crdb_1] Loaded groups -> org.member_group: %d relationships (cumulative=%d)", count, *relCount)
}

// =========================
// Phase 3: group_memberships.csv -> usergroup.{member_user,admin_user}
// =========================
//
// group_memberships.csv: group_id,user_id,role
//   - role currently always "member" in generator
//   - maps directly to usergroup.member_user / usergroup.admin_user

func loadGroupMemberships(client *authzed.Client, batch *[]*v1.RelationshipUpdate, relCount *int, start time.Time) {
	r, f := openCSV("group_memberships.csv")
	defer f.Close()

	// header: group_id,user_id,role
	if _, err := r.Read(); err != nil {
		log.Fatalf("[authzed_crdb_1] read group_memberships header: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[authzed_crdb_1] read group_memberships row: %v", err)
		}
		if len(rec) < 3 {
			log.Fatalf("[authzed_crdb_1] invalid group_memberships row: %#v", rec)
		}

		groupIDRaw := rec[0]
		userIDRaw := rec[1]
		role := rec[2]

		groupID := groupObjectID(groupIDRaw)
		userID := userObjectID(userIDRaw)

		var relation string
		switch role {
		case "admin":
			relation = "admin_user"
		default:
			relation = "member_user"
		}

		*batch = append(*batch, mkCreateRel(
			"usergroup", groupID,
			relation,
			"user", userID,
			"",
		))
		*relCount++
		count++
		flushIfNeeded(client, batch, relCount, start)
	}

	log.Printf("[authzed_crdb_1] Loaded group_memberships: %d relationships (cumulative=%d)", count, *relCount)
}

// =========================
// Phase 4: resources.csv -> resource.org
// =========================
//
// resources.csv: resource_id,org_id
// We assign each resource to its owning organization via resource.org.

func loadResources(client *authzed.Client, batch *[]*v1.RelationshipUpdate, relCount *int, start time.Time) {
	r, f := openCSV("resources.csv")
	defer f.Close()

	// header: resource_id,org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[authzed_crdb_1] read resources header: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[authzed_crdb_1] read resources row: %v", err)
		}
		if len(rec) < 2 {
			log.Fatalf("[authzed_crdb_1] invalid resources row: %#v", rec)
		}

		resIDRaw := rec[0]
		orgIDRaw := rec[1]

		resID := resourceObjectID(resIDRaw)
		orgID := orgObjectID(orgIDRaw)

		*batch = append(*batch, mkCreateRel(
			"resource", resID,
			"org",
			"organization", orgID,
			"",
		))
		*relCount++
		count++
		flushIfNeeded(client, batch, relCount, start)
	}

	log.Printf("[authzed_crdb_1] Loaded resources -> resource.org: %d relationships (cumulative=%d)", count, *relCount)
}

// =========================
// Phase 5: resource_acl.csv -> resource.*
// =========================
//
// resource_acl.csv: resource_id,subject_type,subject_id,relation
//   - subject_type in {"user","group"}
//   - relation in {"manager","viewer"}
//
// Mapping to schemas.zed:
//   - user + manager  -> resource.manager_user@user
//   - user + viewer   -> resource.viewer_user@user
//   - group + manager -> resource.manager_group@usergroup#admin
//   - group + viewer  -> resource.viewer_group@usergroup#member
//
// This mirrors the original modeling intent:
//   * group admins manage resources
//   * group members (and admins) view resources

func loadResourceACL(client *authzed.Client, batch *[]*v1.RelationshipUpdate, relCount *int, start time.Time) {
	r, f := openCSV("resource_acl.csv")
	defer f.Close()

	// header: resource_id,subject_type,subject_id,relation
	if _, err := r.Read(); err != nil {
		log.Fatalf("[authzed_crdb_1] read resource_acl header: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[authzed_crdb_1] read resource_acl row: %v", err)
		}
		if len(rec) < 4 {
			log.Fatalf("[authzed_crdb_1] invalid resource_acl row: %#v", rec)
		}

		resIDRaw := rec[0]
		subjectType := rec[1]
		subjectIDRaw := rec[2]
		aclRelation := rec[3]

		resID := resourceObjectID(resIDRaw)

		switch subjectType {
		case "user":
			userID := userObjectID(subjectIDRaw)

			switch aclRelation {
			case "manager":
				*batch = append(*batch, mkCreateRel(
					"resource", resID,
					"manager_user",
					"user", userID,
					"",
				))
			case "viewer":
				*batch = append(*batch, mkCreateRel(
					"resource", resID,
					"viewer_user",
					"user", userID,
					"",
				))
			default:
				log.Fatalf("[authzed_crdb_1] unknown ACL relation for user: %q", aclRelation)
			}

		case "group":
			groupID := groupObjectID(subjectIDRaw)

			switch aclRelation {
			case "manager":
				// resource.manager_group: usergroup#admin
				*batch = append(*batch, mkCreateRel(
					"resource", resID,
					"manager_group",
					"usergroup", groupID,
					"admin",
				))
			case "viewer":
				// resource.viewer_group: usergroup#member
				*batch = append(*batch, mkCreateRel(
					"resource", resID,
					"viewer_group",
					"usergroup", groupID,
					"member",
				))
			default:
				log.Fatalf("[authzed_crdb_1] unknown ACL relation for group: %q", aclRelation)
			}

		default:
			log.Fatalf("[authzed_crdb_1] unknown subject_type in resource_acl: %q", subjectType)
		}

		*relCount++
		count++
		flushIfNeeded(client, batch, relCount, start)
	}

	log.Printf("[authzed_crdb_1] Loaded resource_acl: %d relationships (cumulative=%d)", count, *relCount)
}

// ============================
// Helpers (unchanged semantics)
// ============================

func mkCreateRel(
	resType, resID, relation string,
	subjectType, subjectID, subjectRel string,
) *v1.RelationshipUpdate {
	return &v1.RelationshipUpdate{
		Operation: v1.RelationshipUpdate_OPERATION_CREATE,
		Relationship: &v1.Relationship{
			Resource: &v1.ObjectReference{
				ObjectType: resType,
				ObjectId:   resID,
			},
			Relation: relation,
			Subject: &v1.SubjectReference{
				Object: &v1.ObjectReference{
					ObjectType: subjectType,
					ObjectId:   subjectID,
				},
				OptionalRelation: subjectRel,
			},
		},
	}
}

func flushIfNeeded(client *authzed.Client, batch *[]*v1.RelationshipUpdate, relCount *int, start time.Time) {
	if len(*batch) < batchSize {
		return
	}
	writeBatchWithToken(client, *batch)
	*batch = (*batch)[:0]

	if (*relCount)%1_000_000 == 0 {
		log.Printf("[authzed_crdb_1] ... %d relationships inserted (elapsed=%s)",
			*relCount, time.Since(start).Truncate(time.Millisecond))
	}
}

func writeBatch(client *authzed.Client, batch []*v1.RelationshipUpdate) {
	ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
	defer cancel()
	_, err := retryWriteRelationships(ctx, client, batch)
	if err != nil {
		if st, ok := status.FromError(err); ok && st.Code() == codes.AlreadyExists {
			// Relationship(s) already exist (idempotent import). Log and continue.
			log.Printf("[authzed_crdb_1] WriteRelationships skipped (AlreadyExists): %v", err)
			return
		}
		log.Fatalf("[authzed_crdb_1] WriteRelationships failed: %v", err)
	}
}

// ============================
// Helpers: Cached consistency token for faster subsequent reads
// ============================

// lastConsistencyToken stores the token from the last write to enable caveat-free
// consistent reads in downstream operations (like benchmarks).
var lastConsistencyToken *v1.ZedToken

// GetLastConsistencyToken returns the last write's consistency token for use in
// benchmarks to ensure reads reflect the loaded data without explicit caveat checks.
func GetLastConsistencyToken() *v1.ZedToken {
	return lastConsistencyToken
}

// writeBatchWithToken writes relationships and caches the consistency token.
func writeBatchWithToken(client *authzed.Client, batch []*v1.RelationshipUpdate) {
	ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
	defer cancel()
	resp, err := retryWriteRelationships(ctx, client, batch)
	if err != nil {
		if st, ok := status.FromError(err); ok && st.Code() == codes.AlreadyExists {
			log.Printf("[authzed_crdb_1] WriteRelationships skipped (AlreadyExists): %v", err)
			return
		}
		log.Fatalf("[authzed_crdb_1] WriteRelationships failed: %v", err)
	}

	if resp != nil && resp.WrittenAt != nil {
		lastConsistencyToken = resp.WrittenAt
	}
}

// retryWriteRelationships retries WriteRelationships when CockroachDB reports
// remote wall time / clock skew errors. It returns the response or final error.
func retryWriteRelationships(ctx context.Context, client *authzed.Client, batch []*v1.RelationshipUpdate) (*v1.WriteRelationshipsResponse, error) {
	maxAttempts := 3
	for attempt := 1; attempt <= maxAttempts; attempt++ {
		resp, err := client.WriteRelationships(ctx, &v1.WriteRelationshipsRequest{Updates: batch})
		if err == nil {
			return resp, nil
		}

		// If error indicates clock skew / remote wall time too far ahead, retry.
		if st, ok := status.FromError(err); ok && st.Code() == codes.Unknown {
			msg := st.Message()
			if strings.Contains(msg, "wall time is too far ahead") || strings.Contains(strings.ToLower(msg), "clock skew") {
				wait := time.Duration(attempt) * time.Second
				log.Printf("[authzed_crdb_1] WriteRelationships attempt %d/%d failed due to clock skew: %v â€” retrying in %s", attempt, maxAttempts, err, wait)
				time.Sleep(wait)
				continue
			}
		}

		// Not a retryable error.
		return nil, err
	}

	return nil, status.Errorf(codes.Unknown, "write failed after %d attempts due to clock skew", maxAttempts)
}
