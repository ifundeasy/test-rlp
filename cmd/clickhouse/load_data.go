package clickhouse

import (
	"context"
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"

	"test-tls/infrastructure"
)

const (
	dataDir   = "data"
	batchSize = 2000
)

// ClickhouseCreateData loads CSV dataset into ClickHouse tables. It will
// truncate the destination tables first (overwrite if exists) and then
// bulk-insert rows from all CSVs generated by cmd/csv/generate.go. It also
// computes a transitive expansion into `group_members_expanded` to support
// nested groups as expected by the ClickHouse schema.
func ClickhouseCreateData() {
	ctx, cancel := context.WithTimeout(context.Background(), 120*time.Second)
	defer cancel()

	db, cleanup, err := infrastructure.NewClickhouseFromEnv(ctx)
	if err != nil {
		log.Fatalf("[clickhouse] connect: %v", err)
	}
	defer cleanup()

	start := time.Now()
	log.Printf("[clickhouse] == Starting Clickhouse data import from CSV in %q ==", dataDir)

	// Read resources first to be able to look up org_id when inserting resource_acl
	resourcesMap := make(map[string]uint32)

	// Truncate target tables to ensure overwrite semantics
	tablesToTruncate := []string{
		"organizations", "users", "groups", "org_memberships",
		"group_memberships", "group_hierarchy", "group_members_expanded",
		"resources", "resource_acl",
	}
	for _, t := range tablesToTruncate {
		q := fmt.Sprintf("TRUNCATE TABLE %s", t)
		if _, err := db.ExecContext(ctx, q); err != nil {
			log.Fatalf("[clickhouse] truncate %s: %v", t, err)
		}
	}

	// Helper to open a csv reader
	openCSV := func(name string) (*csv.Reader, *os.File) {
		full := filepath.Join(dataDir, name)
		f, err := os.Open(full)
		if err != nil {
			log.Fatalf("[clickhouse] open %s: %v", full, err)
		}
		return csv.NewReader(f), f
	}

	// Bulk insert helper: builds a multi-row INSERT with placeholders.
	insertRows := func(table string, cols []string, rows [][]interface{}) error {
		if len(rows) == 0 {
			return nil
		}
		// build query like: INSERT INTO table (c1,c2) VALUES (?,?),(?,?)...
		colList := strings.Join(cols, ",")
		var sb strings.Builder
		sb.WriteString("INSERT INTO ")
		sb.WriteString(table)
		sb.WriteString(" (")
		sb.WriteString(colList)
		sb.WriteString(") VALUES ")

		placeholdersPerRow := make([]string, len(cols))
		for i := range placeholdersPerRow {
			placeholdersPerRow[i] = "?"
		}
		rowPlaceholder := "(" + strings.Join(placeholdersPerRow, ",") + ")"

		args := make([]interface{}, 0, len(rows)*len(cols))
		for i, r := range rows {
			if i > 0 {
				sb.WriteString(",")
			}
			sb.WriteString(rowPlaceholder)
			args = append(args, r...)
		}

		_, err := db.ExecContext(ctx, sb.String(), args...)
		if err != nil {
			return fmt.Errorf("insert %s: %w", table, err)
		}
		return nil
	}

	// organizations
	func() {
		r, f := openCSV("organizations.csv")
		defer f.Close()
		// header
		if _, err := r.Read(); err != nil {
			log.Fatalf("[clickhouse] read organizations header: %v", err)
		}
		rows := make([][]interface{}, 0, batchSize)
		count := 0
		for {
			rec, err := r.Read()
			if err == io.EOF {
				break
			}
			if err != nil {
				log.Fatalf("[clickhouse] read organizations row: %v", err)
			}
			if len(rec) < 1 {
				log.Fatalf("[clickhouse] invalid organizations row: %#v", rec)
			}
			rows = append(rows, []interface{}{rec[0]})
			count++
			if count%10000 == 0 {
				log.Printf("[clickhouse] Loaded organizations progress: %d rows elapsed=%s", count, time.Since(start).Truncate(time.Millisecond))
			}
			if len(rows) >= batchSize {
				if err := insertRows("organizations", []string{"org_id"}, rows); err != nil {
					log.Fatalf("[clickhouse] %v", err)
				}
				rows = rows[:0]
			}
		}
		if len(rows) > 0 {
			if err := insertRows("organizations", []string{"org_id"}, rows); err != nil {
				log.Fatalf("[clickhouse] %v", err)
			}
		}
		log.Printf("[clickhouse] Loaded organizations: %d rows", count)
	}()

	// users
	func() {
		r, f := openCSV("users.csv")
		defer f.Close()
		if _, err := r.Read(); err != nil {
			log.Fatalf("[clickhouse] read users header: %v", err)
		}
		rows := make([][]interface{}, 0, batchSize)
		count := 0
		for {
			rec, err := r.Read()
			if err == io.EOF {
				break
			}
			if err != nil {
				log.Fatalf("[clickhouse] read users row: %v", err)
			}
			if len(rec) < 2 {
				log.Fatalf("[clickhouse] invalid users row: %#v", rec)
			}
			rows = append(rows, []interface{}{rec[0], rec[1]})
			count++
			if count%10000 == 0 {
				log.Printf("[clickhouse] Loaded users progress: %d rows elapsed=%s", count, time.Since(start).Truncate(time.Millisecond))
			}
			if len(rows) >= batchSize {
				if err := insertRows("users", []string{"user_id", "primary_org_id"}, rows); err != nil {
					log.Fatalf("[clickhouse] %v", err)
				}
				rows = rows[:0]
			}
		}
		if len(rows) > 0 {
			if err := insertRows("users", []string{"user_id", "primary_org_id"}, rows); err != nil {
				log.Fatalf("[clickhouse] %v", err)
			}
		}
		log.Printf("[clickhouse] Loaded users: %d rows", count)
	}()

	// groups
	func() {
		r, f := openCSV("groups.csv")
		defer f.Close()
		if _, err := r.Read(); err != nil {
			log.Fatalf("[clickhouse] read groups header: %v", err)
		}
		rows := make([][]interface{}, 0, batchSize)
		count := 0
		for {
			rec, err := r.Read()
			if err == io.EOF {
				break
			}
			if err != nil {
				log.Fatalf("[clickhouse] read groups row: %v", err)
			}
			if len(rec) < 2 {
				log.Fatalf("[clickhouse] invalid groups row: %#v", rec)
			}
			rows = append(rows, []interface{}{rec[0], rec[1]})
			count++
			if count%10000 == 0 {
				log.Printf("[clickhouse] Loaded groups progress: %d rows elapsed=%s", count, time.Since(start).Truncate(time.Millisecond))
			}
			if len(rows) >= batchSize {
				if err := insertRows("groups", []string{"group_id", "org_id"}, rows); err != nil {
					log.Fatalf("[clickhouse] %v", err)
				}
				rows = rows[:0]
			}
		}
		if len(rows) > 0 {
			if err := insertRows("groups", []string{"group_id", "org_id"}, rows); err != nil {
				log.Fatalf("[clickhouse] %v", err)
			}
		}
		log.Printf("[clickhouse] Loaded groups: %d rows", count)
	}()

	// org_memberships
	func() {
		r, f := openCSV("org_memberships.csv")
		defer f.Close()
		if _, err := r.Read(); err != nil {
			log.Fatalf("[clickhouse] read org_memberships header: %v", err)
		}
		rows := make([][]interface{}, 0, batchSize)
		count := 0
		for {
			rec, err := r.Read()
			if err == io.EOF {
				break
			}
			if err != nil {
				log.Fatalf("[clickhouse] read org_memberships row: %v", err)
			}
			if len(rec) < 3 {
				log.Fatalf("[clickhouse] invalid org_memberships row: %#v", rec)
			}
			role := rec[2]
			if role != "admin" {
				role = "member"
			}
			rows = append(rows, []interface{}{rec[0], rec[1], role})
			count++
			if count%10000 == 0 {
				log.Printf("[clickhouse] Loaded org_memberships progress: %d rows elapsed=%s", count, time.Since(start).Truncate(time.Millisecond))
			}
			if len(rows) >= batchSize {
				if err := insertRows("org_memberships", []string{"org_id", "user_id", "role"}, rows); err != nil {
					log.Fatalf("[clickhouse] %v", err)
				}
				rows = rows[:0]
			}
		}
		if len(rows) > 0 {
			if err := insertRows("org_memberships", []string{"org_id", "user_id", "role"}, rows); err != nil {
				log.Fatalf("[clickhouse] %v", err)
			}
		}
		log.Printf("[clickhouse] Loaded org_memberships: %d rows", count)
	}()

	// group_memberships (also build direct membership map for expansion)
	groupMembersDirect := make(map[string]map[string]string) // groupID -> userID -> role
	func() {
		r, f := openCSV("group_memberships.csv")
		defer f.Close()
		if _, err := r.Read(); err != nil {
			log.Fatalf("[clickhouse] read group_memberships header: %v", err)
		}
		rows := make([][]interface{}, 0, batchSize)
		count := 0
		for {
			rec, err := r.Read()
			if err == io.EOF {
				break
			}
			if err != nil {
				log.Fatalf("[clickhouse] read group_memberships row: %v", err)
			}
			if len(rec) < 3 {
				log.Fatalf("[clickhouse] invalid group_memberships row: %#v", rec)
			}
			role := rec[2]
			switch role {
			case "direct_manager", "admin", "manager":
				role = "manager"
			default:
				role = "member"
			}
			rows = append(rows, []interface{}{rec[0], rec[1], role})
			// store direct
			gm := groupMembersDirect[rec[0]]
			if gm == nil {
				gm = make(map[string]string)
				groupMembersDirect[rec[0]] = gm
			}
			gm[rec[1]] = role
			count++
			if count%10000 == 0 {
				log.Printf("[clickhouse] Loaded group_memberships progress: %d rows elapsed=%s", count, time.Since(start).Truncate(time.Millisecond))
			}
			if len(rows) >= batchSize {
				if err := insertRows("group_memberships", []string{"group_id", "user_id", "role"}, rows); err != nil {
					log.Fatalf("[clickhouse] %v", err)
				}
				rows = rows[:0]
			}
		}
		if len(rows) > 0 {
			if err := insertRows("group_memberships", []string{"group_id", "user_id", "role"}, rows); err != nil {
				log.Fatalf("[clickhouse] %v", err)
			}
		}
		log.Printf("[clickhouse] Loaded group_memberships: %d rows", count)
	}()

	// group_hierarchy (also build adjacency)
	groupChildren := make(map[string]map[string]string) // parent -> child -> relation
	func() {
		r, f := openCSV("group_hierarchy.csv")
		defer f.Close()
		// header may not exist
		if _, err := r.Read(); err != nil {
			if os.IsNotExist(err) {
				log.Printf("[clickhouse] group_hierarchy.csv not found, skipping nested groups")
				return
			}
			log.Fatalf("[clickhouse] read group_hierarchy header: %v", err)
		}
		rows := make([][]interface{}, 0, batchSize)
		count := 0
		for {
			rec, err := r.Read()
			if err == io.EOF {
				break
			}
			if err != nil {
				log.Fatalf("[clickhouse] read group_hierarchy row: %v", err)
			}
			if len(rec) < 3 {
				log.Fatalf("[clickhouse] invalid group_hierarchy row: %#v", rec)
			}
			rel := rec[2]
			if rel != "manager_group" && rel != "member_group" {
				log.Fatalf("[clickhouse] unknown group_hierarchy relation: %q", rel)
			}
			rows = append(rows, []interface{}{rec[0], rec[1], rel})
			// store adjacency
			m := groupChildren[rec[0]]
			if m == nil {
				m = make(map[string]string)
				groupChildren[rec[0]] = m
			}
			m[rec[1]] = rel
			count++
			if count%10000 == 0 {
				log.Printf("[clickhouse] Loaded group_hierarchy progress: %d rows elapsed=%s", count, time.Since(start).Truncate(time.Millisecond))
			}
			if len(rows) >= batchSize {
				if err := insertRows("group_hierarchy", []string{"parent_group_id", "child_group_id", "relation"}, rows); err != nil {
					log.Fatalf("[clickhouse] %v", err)
				}
				rows = rows[:0]
			}
		}
		if len(rows) > 0 {
			if err := insertRows("group_hierarchy", []string{"parent_group_id", "child_group_id", "relation"}, rows); err != nil {
				log.Fatalf("[clickhouse] %v", err)
			}
		}
		log.Printf("[clickhouse] Loaded group_hierarchy: %d rows", count)
	}()

	// resources
	func() {
		r, f := openCSV("resources.csv")
		defer f.Close()
		if _, err := r.Read(); err != nil {
			log.Fatalf("[clickhouse] read resources header: %v", err)
		}
		rows := make([][]interface{}, 0, batchSize)
		count := 0
		for {
			rec, err := r.Read()
			if err == io.EOF {
				break
			}
			if err != nil {
				log.Fatalf("[clickhouse] read resources row: %v", err)
			}
			if len(rec) < 2 {
				log.Fatalf("[clickhouse] invalid resources row: %#v", rec)
			}
			// store mapping for resource_acl org lookup
			resourcesMap[rec[0]] = toUint32StringVal(rec[1])
			rows = append(rows, []interface{}{rec[0], rec[1]})
			count++
			if count%10000 == 0 {
				log.Printf("[clickhouse] Loaded resources progress: %d rows elapsed=%s", count, time.Since(start).Truncate(time.Millisecond))
			}
			if len(rows) >= batchSize {
				if err := insertRows("resources", []string{"resource_id", "org_id"}, rows); err != nil {
					log.Fatalf("[clickhouse] %v", err)
				}
				rows = rows[:0]
			}
		}
		if len(rows) > 0 {
			if err := insertRows("resources", []string{"resource_id", "org_id"}, rows); err != nil {
				log.Fatalf("[clickhouse] %v", err)
			}
		}
		log.Printf("[clickhouse] Loaded resources: %d rows", count)
	}()

	// resource_acl
	func() {
		r, f := openCSV("resource_acl.csv")
		defer f.Close()
		if _, err := r.Read(); err != nil {
			log.Fatalf("[clickhouse] read resource_acl header: %v", err)
		}
		rows := make([][]interface{}, 0, batchSize)
		count := 0
		for {
			rec, err := r.Read()
			if err == io.EOF {
				break
			}
			if err != nil {
				log.Fatalf("[clickhouse] read resource_acl row: %v", err)
			}
			if len(rec) < 4 {
				log.Fatalf("[clickhouse] invalid resource_acl row: %#v", rec)
			}
			resID := rec[0]
			subjType := rec[1]
			subjID := rec[2]
			rel := rec[3]

			// map relation names to simple 'viewer'|'manager'
			switch rel {
			case "manager_user", "manager_group", "manager":
				rel = "manager"
			case "viewer_user", "viewer_group", "viewer":
				rel = "viewer"
			default:
				log.Fatalf("[clickhouse] unknown resource_acl relation: %q", rel)
			}

			// lookup org_id from resourcesMap
			orgIDVal, ok := resourcesMap[resID]
			if !ok {
				log.Fatalf("[clickhouse] resource %s not found in resources.csv (needed for org_id)", resID)
			}

			// subject_type must be 'user' or 'group'
			if subjType != "user" && subjType != "group" {
				log.Fatalf("[clickhouse] unknown subject_type in resource_acl: %q", subjType)
			}

			rows = append(rows, []interface{}{resID, fmt.Sprintf("%d", orgIDVal), subjType, subjID, rel})
			count++
			if count%10000 == 0 {
				log.Printf("[clickhouse] Loaded resource_acl progress: %d rows elapsed=%s", count, time.Since(start).Truncate(time.Millisecond))
			}
			if len(rows) >= batchSize {
				if err := insertRows("resource_acl", []string{"resource_id", "org_id", "subject_type", "subject_id", "relation"}, rows); err != nil {
					log.Fatalf("[clickhouse] %v", err)
				}
				rows = rows[:0]
			}
		}
		if len(rows) > 0 {
			if err := insertRows("resource_acl", []string{"resource_id", "org_id", "subject_type", "subject_id", "relation"}, rows); err != nil {
				log.Fatalf("[clickhouse] %v", err)
			}
		}
		log.Printf("[clickhouse] Loaded resource_acl: %d rows", count)
	}()

	// Compute group_members_expanded transitive closure via iterative propagation
	func() {
		// start with direct memberships
		expanded := make(map[string]map[string]string) // group -> user -> role
		for g, m := range groupMembersDirect {
			em := make(map[string]string)
			for u, r := range m {
				em[u] = r
			}
			expanded[g] = em
		}

		changed := true
		for changed {
			changed = false
			// for every parent -> child edge
			for parent, children := range groupChildren {
				em := expanded[parent]
				if em == nil {
					em = make(map[string]string)
					expanded[parent] = em
				}
				for child, rel := range children {
					// ensure child has an expanded set (may be empty)
					childSet := expanded[child]
					if childSet == nil {
						childSet = make(map[string]string)
					}
					// for each user in child's expanded set, decide whether to import
					for u, r := range childSet {
						// if edge is member_group, propagate only 'member' roles
						// if edge is manager_group, propagate only 'manager' roles
						if rel == "member_group" {
							if r != "member" {
								continue
							}
							if _, ok := em[u]; !ok {
								em[u] = "member"
								changed = true
							}
						} else if rel == "manager_group" {
							if r != "manager" {
								continue
							}
							if _, ok := em[u]; !ok {
								em[u] = "manager"
								changed = true
							}
						}
					}
				}
			}
			// also ensure direct members propagate into expanded (in case children referenced new groups)
			for g, m := range groupMembersDirect {
				em := expanded[g]
				if em == nil {
					em = make(map[string]string)
					expanded[g] = em
				}
				for u, r := range m {
					if _, ok := em[u]; !ok {
						em[u] = r
						changed = true
					}
				}
			}
		}

		// write expanded into table
		rows := make([][]interface{}, 0, batchSize)
		total := 0
		for g, m := range expanded {
			for u, r := range m {
				rows = append(rows, []interface{}{g, u, r})
				total++
				if len(rows) >= batchSize {
					if err := insertRows("group_members_expanded", []string{"group_id", "user_id", "role"}, rows); err != nil {
						log.Fatalf("[clickhouse] %v", err)
					}
					rows = rows[:0]
				}
			}
		}
		if len(rows) > 0 {
			if err := insertRows("group_members_expanded", []string{"group_id", "user_id", "role"}, rows); err != nil {
				log.Fatalf("[clickhouse] %v", err)
			}
		}
		log.Printf("[clickhouse] Populated group_members_expanded: %d rows", total)
	}()

	elapsed := time.Since(start).Truncate(time.Millisecond)
	log.Printf("[clickhouse] Clickhouse data import DONE: elapsed=%s", elapsed)
}

// helper: parse string to uint32 with fallback 0
func toUint32StringVal(s string) uint32 {
	var v uint32
	var tmp uint64
	if _, err := fmt.Sscan(strings.TrimSpace(s), &tmp); err == nil {
		v = uint32(tmp)
	} else {
		v = 0
	}
	return v
}
