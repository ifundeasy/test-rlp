package clickhouse_1

import (
	"context"
	"database/sql"
	"encoding/csv"
	"io"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"time"

	"test-tls/infrastructure"
)

const dataDir = "data"

// ClickhouseCreateData loads the deterministic relational ACL dataset generated by
// cmd/csv/create-data.go into ClickHouse tables defined by ClickhouseCreateSchemas.
//
// CSV files:
//
//	organizations.csv:     org_id
//	users.csv:             user_id,primary_org_id
//	groups.csv:            group_id,org_id
//	org_memberships.csv:   org_id,user_id,role
//	group_memberships.csv: group_id,user_id,role
//	resources.csv:         resource_id,org_id
//	resource_acl.csv:      resource_id,subject_type,subject_id,relation
//
// In ClickHouse, resource_acl has an extra org_id column, derived from resources.csv.
func ClickhouseCreateData() {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Minute)
	defer cancel()

	db, cleanup, err := infrastructure.NewClickhouseFromEnv(ctx)
	if err != nil {
		log.Fatalf("[clickhouse_1] create_data: connect failed: %v", err)
	}
	defer cleanup()

	startAll := time.Now()
	log.Printf("[clickhouse_1] create_data: loading CSV data from %q ...", dataDir)

	loadOrganizations(ctx, db)
	loadUsers(ctx, db)
	loadGroups(ctx, db)
	loadOrgMemberships(ctx, db)
	loadGroupMemberships(ctx, db)
	loadResources(ctx, db)
	loadResourceACL(ctx, db)

	log.Printf("[clickhouse_1] create_data: ALL DONE in %s", time.Since(startAll).Truncate(time.Millisecond))
}

// =========================
// CSV helper
// =========================

func openCSV(name string) (*csv.Reader, *os.File) {
	full := filepath.Join(dataDir, name)
	f, err := os.Open(full)
	if err != nil {
		log.Fatalf("[clickhouse_1] create_data: open %s: %v", full, err)
	}
	r := csv.NewReader(f)
	return r, f
}

func mustParseUint32(s, field string) uint32 {
	v, err := strconv.ParseUint(s, 10, 32)
	if err != nil {
		log.Fatalf("[clickhouse_1] parse error for %s=%q: %v", field, s, err)
	}
	return uint32(v)
}

// =========================
// Load functions per table
// =========================

func loadOrganizations(ctx context.Context, db *sql.DB) {
	start := time.Now()
	r, f := openCSV("organizations.csv")
	defer f.Close()

	// organizations.csv: org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[clickhouse_1] organizations: read header failed: %v", err)
	}

	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		log.Fatalf("[clickhouse_1] organizations: begin tx failed: %v", err)
	}

	stmt, err := tx.PrepareContext(ctx, `
		INSERT INTO organizations (org_id)
		VALUES (?)
	`)
	if err != nil {
		log.Fatalf("[clickhouse_1] organizations: prepare insert failed: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[clickhouse_1] organizations: read row failed: %v", err)
		}
		if len(rec) < 1 {
			log.Fatalf("[clickhouse_1] organizations: invalid row: %#v", rec)
		}

		orgID := mustParseUint32(rec[0], "organizations.org_id")

		if _, err := stmt.ExecContext(ctx, orgID); err != nil {
			log.Fatalf("[clickhouse_1] organizations: insert failed: %v", err)
		}
		count++
	}

	if err := stmt.Close(); err != nil {
		log.Fatalf("[clickhouse_1] organizations: close stmt failed: %v", err)
	}
	if err := tx.Commit(); err != nil {
		log.Fatalf("[clickhouse_1] organizations: commit failed: %v", err)
	}

	log.Printf("[clickhouse_1] organizations: inserted %d rows in %s",
		count, time.Since(start).Truncate(time.Millisecond))
}

func loadUsers(ctx context.Context, db *sql.DB) {
	start := time.Now()
	r, f := openCSV("users.csv")
	defer f.Close()

	// users.csv: user_id,primary_org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[clickhouse_1] users: read header failed: %v", err)
	}

	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		log.Fatalf("[clickhouse_1] users: begin tx failed: %v", err)
	}

	stmt, err := tx.PrepareContext(ctx, `
		INSERT INTO users (user_id, primary_org_id)
		VALUES (?, ?)
	`)
	if err != nil {
		log.Fatalf("[clickhouse_1] users: prepare insert failed: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[clickhouse_1] users: read row failed: %v", err)
		}
		if len(rec) < 2 {
			log.Fatalf("[clickhouse_1] users: invalid row: %#v", rec)
		}

		userID := mustParseUint32(rec[0], "users.user_id")
		primaryOrgID := mustParseUint32(rec[1], "users.primary_org_id")

		if _, err := stmt.ExecContext(ctx, userID, primaryOrgID); err != nil {
			log.Fatalf("[clickhouse_1] users: insert failed: %v", err)
		}
		count++
	}

	if err := stmt.Close(); err != nil {
		log.Fatalf("[clickhouse_1] users: close stmt failed: %v", err)
	}
	if err := tx.Commit(); err != nil {
		log.Fatalf("[clickhouse_1] users: commit failed: %v", err)
	}

	log.Printf("[clickhouse_1] users: inserted %d rows in %s",
		count, time.Since(start).Truncate(time.Millisecond))
}

func loadGroups(ctx context.Context, db *sql.DB) {
	start := time.Now()
	r, f := openCSV("groups.csv")
	defer f.Close()

	// groups.csv: group_id,org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[clickhouse_1] groups: read header failed: %v", err)
	}

	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		log.Fatalf("[clickhouse_1] groups: begin tx failed: %v", err)
	}

	stmt, err := tx.PrepareContext(ctx, `
		INSERT INTO groups (group_id, org_id)
		VALUES (?, ?)
	`)
	if err != nil {
		log.Fatalf("[clickhouse_1] groups: prepare insert failed: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[clickhouse_1] groups: read row failed: %v", err)
		}
		if len(rec) < 2 {
			log.Fatalf("[clickhouse_1] groups: invalid row: %#v", rec)
		}

		groupID := mustParseUint32(rec[0], "groups.group_id")
		orgID := mustParseUint32(rec[1], "groups.org_id")

		if _, err := stmt.ExecContext(ctx, groupID, orgID); err != nil {
			log.Fatalf("[clickhouse_1] groups: insert failed: %v", err)
		}
		count++
	}

	if err := stmt.Close(); err != nil {
		log.Fatalf("[clickhouse_1] groups: close stmt failed: %v", err)
	}
	if err := tx.Commit(); err != nil {
		log.Fatalf("[clickhouse_1] groups: commit failed: %v", err)
	}

	log.Printf("[clickhouse_1] groups: inserted %d rows in %s",
		count, time.Since(start).Truncate(time.Millisecond))
}

func loadOrgMemberships(ctx context.Context, db *sql.DB) {
	start := time.Now()
	r, f := openCSV("org_memberships.csv")
	defer f.Close()

	// org_memberships.csv: org_id,user_id,role
	if _, err := r.Read(); err != nil {
		log.Fatalf("[clickhouse_1] org_memberships: read header failed: %v", err)
	}

	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		log.Fatalf("[clickhouse_1] org_memberships: begin tx failed: %v", err)
	}

	stmt, err := tx.PrepareContext(ctx, `
		INSERT INTO org_memberships (org_id, user_id, role)
		VALUES (?, ?, ?)
	`)
	if err != nil {
		log.Fatalf("[clickhouse_1] org_memberships: prepare insert failed: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[clickhouse_1] org_memberships: read row failed: %v", err)
		}
		if len(rec) < 3 {
			log.Fatalf("[clickhouse_1] org_memberships: invalid row: %#v", rec)
		}

		orgID := mustParseUint32(rec[0], "org_memberships.org_id")
		userID := mustParseUint32(rec[1], "org_memberships.user_id")
		role := rec[2] // Enum8 will accept string labels

		if _, err := stmt.ExecContext(ctx, orgID, userID, role); err != nil {
			log.Fatalf("[clickhouse_1] org_memberships: insert failed: %v", err)
		}
		count++
	}

	if err := stmt.Close(); err != nil {
		log.Fatalf("[clickhouse_1] org_memberships: close stmt failed: %v", err)
	}
	if err := tx.Commit(); err != nil {
		log.Fatalf("[clickhouse_1] org_memberships: commit failed: %v", err)
	}

	log.Printf("[clickhouse_1] org_memberships: inserted %d rows in %s",
		count, time.Since(start).Truncate(time.Millisecond))
}

func loadGroupMemberships(ctx context.Context, db *sql.DB) {
	start := time.Now()
	r, f := openCSV("group_memberships.csv")
	defer f.Close()

	// group_memberships.csv: group_id,user_id,role
	if _, err := r.Read(); err != nil {
		log.Fatalf("[clickhouse_1] group_memberships: read header failed: %v", err)
	}

	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		log.Fatalf("[clickhouse_1] group_memberships: begin tx failed: %v", err)
	}

	stmt, err := tx.PrepareContext(ctx, `
		INSERT INTO group_memberships (group_id, user_id, role)
		VALUES (?, ?, ?)
	`)
	if err != nil {
		log.Fatalf("[clickhouse_1] group_memberships: prepare insert failed: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[clickhouse_1] group_memberships: read row failed: %v", err)
		}
		if len(rec) < 3 {
			log.Fatalf("[clickhouse_1] group_memberships: invalid row: %#v", rec)
		}

		groupID := mustParseUint32(rec[0], "group_memberships.group_id")
		userID := mustParseUint32(rec[1], "group_memberships.user_id")
		role := rec[2]

		if _, err := stmt.ExecContext(ctx, groupID, userID, role); err != nil {
			log.Fatalf("[clickhouse_1] group_memberships: insert failed: %v", err)
		}
		count++
	}

	if err := stmt.Close(); err != nil {
		log.Fatalf("[clickhouse_1] group_memberships: close stmt failed: %v", err)
	}
	if err := tx.Commit(); err != nil {
		log.Fatalf("[clickhouse_1] group_memberships: commit failed: %v", err)
	}

	log.Printf("[clickhouse_1] group_memberships: inserted %d rows in %s",
		count, time.Since(start).Truncate(time.Millisecond))
}

func loadResources(ctx context.Context, db *sql.DB) {
	start := time.Now()
	r, f := openCSV("resources.csv")
	defer f.Close()

	// resources.csv: resource_id,org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[clickhouse_1] resources: read header failed: %v", err)
	}

	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		log.Fatalf("[clickhouse_1] resources: begin tx failed: %v", err)
	}

	stmt, err := tx.PrepareContext(ctx, `
		INSERT INTO resources (resource_id, org_id)
		VALUES (?, ?)
	`)
	if err != nil {
		log.Fatalf("[clickhouse_1] resources: prepare insert failed: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[clickhouse_1] resources: read row failed: %v", err)
		}
		if len(rec) < 2 {
			log.Fatalf("[clickhouse_1] resources: invalid row: %#v", rec)
		}

		resourceID := mustParseUint32(rec[0], "resources.resource_id")
		orgID := mustParseUint32(rec[1], "resources.org_id")

		if _, err := stmt.ExecContext(ctx, resourceID, orgID); err != nil {
			log.Fatalf("[clickhouse_1] resources: insert failed: %v", err)
		}
		count++
	}

	if err := stmt.Close(); err != nil {
		log.Fatalf("[clickhouse_1] resources: close stmt failed: %v", err)
	}
	if err := tx.Commit(); err != nil {
		log.Fatalf("[clickhouse_1] resources: commit failed: %v", err)
	}

	log.Printf("[clickhouse_1] resources: inserted %d rows in %s",
		count, time.Since(start).Truncate(time.Millisecond))
}

// buildResourceOrgMap reads resources.csv to map resource_id -> org_id (as strings)
// so we can denormalize org_id into resource_acl.
func buildResourceOrgMap() map[string]string {
	r, f := openCSV("resources.csv")
	defer f.Close()

	// header
	if _, err := r.Read(); err != nil {
		log.Fatalf("[clickhouse_1] buildResourceOrgMap: read header failed: %v", err)
	}

	m := make(map[string]string, 1024)

	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[clickhouse_1] buildResourceOrgMap: read row failed: %v", err)
		}
		if len(rec) < 2 {
			log.Fatalf("[clickhouse_1] buildResourceOrgMap: invalid row: %#v", rec)
		}
		resID := rec[0]
		orgID := rec[1]
		m[resID] = orgID
	}

	return m
}

func loadResourceACL(ctx context.Context, db *sql.DB) {
	start := time.Now()

	// Build map resource_id -> org_id from resources.csv
	resOrg := buildResourceOrgMap()

	r, f := openCSV("resource_acl.csv")
	defer f.Close()

	// resource_acl.csv: resource_id,subject_type,subject_id,relation
	if _, err := r.Read(); err != nil {
		log.Fatalf("[clickhouse_1] resource_acl: read header failed: %v", err)
	}

	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		log.Fatalf("[clickhouse_1] resource_acl: begin tx failed: %v", err)
	}

	stmt, err := tx.PrepareContext(ctx, `
		INSERT INTO resource_acl (resource_id, org_id, subject_type, subject_id, relation)
		VALUES (?, ?, ?, ?, ?)
	`)
	if err != nil {
		log.Fatalf("[clickhouse_1] resource_acl: prepare insert failed: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[clickhouse_1] resource_acl: read row failed: %v", err)
		}
		if len(rec) < 4 {
			log.Fatalf("[clickhouse_1] resource_acl: invalid row: %#v", rec)
		}

		resIDStr := rec[0]
		subjectType := rec[1]
		subjectIDStr := rec[2]
		relation := rec[3]

		orgIDStr, ok := resOrg[resIDStr]
		if !ok {
			log.Fatalf("[clickhouse_1] resource_acl: missing org_id for resource_id=%s", resIDStr)
		}

		resourceID := mustParseUint32(resIDStr, "resource_acl.resource_id")
		orgID := mustParseUint32(orgIDStr, "resource_acl.org_id")
		subjectID := mustParseUint32(subjectIDStr, "resource_acl.subject_id")

		if _, err := stmt.ExecContext(ctx, resourceID, orgID, subjectType, subjectID, relation); err != nil {
			log.Fatalf("[clickhouse_1] resource_acl: insert failed: %v", err)
		}
		count++
	}

	if err := stmt.Close(); err != nil {
		log.Fatalf("[clickhouse_1] resource_acl: close stmt failed: %v", err)
	}
	if err := tx.Commit(); err != nil {
		log.Fatalf("[clickhouse_1] resource_acl: commit failed: %v", err)
	}

	log.Printf("[clickhouse_1] resource_acl: inserted %d rows in %s",
		count, time.Since(start).Truncate(time.Millisecond))
}
