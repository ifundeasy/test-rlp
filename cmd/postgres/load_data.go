// cmd/postgres/load_data.go
package postgres

import (
	"context"
	"database/sql"
	"encoding/csv"
	"io"
	"log"
	"os"
	"path/filepath"
	"time"

	pq "github.com/lib/pq"

	"test-tls/infrastructure"
)

const dataDir = "data"

// PostgresCreateData loads the deterministic relational ACL dataset generated by
// cmd/csv/load_data.go into PostgreSQL tables defined in schemas.sql.
//
// Tables and CSV files:
//
//	organizations.csv:     org_id
//	users.csv:             user_id,org_id
//	groups.csv:            group_id,org_id
//	org_memberships.csv:   org_id,user_id,role
//	group_memberships.csv: group_id,user_id,role
//	resources.csv:         resource_id,org_id
//	resource_acl.csv:      resource_id,subject_type,subject_id,relation
func PostgresCreateData() {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Minute)
	defer cancel()

	db, cleanup, err := infrastructure.NewPostgresFromEnv(ctx)
	if err != nil {
		log.Fatalf("[postgres] create postgres client: %v", err)
	}
	defer cleanup()
	startAll := time.Now()
	total := 0

	log.Printf("[postgres] == Starting Postgres data import from CSV in %q ==", dataDir)

	loadOrganizations(db, &total)
	loadUsers(db, &total)
	loadGroups(db, &total)
	loadOrgMemberships(db, &total)
	loadGroupMemberships(db, &total)
	loadGroupHierarchy(db, &total)
	loadResources(db, &total)
	loadResourceACL(db, &total)

	// Refresh materialized view to precompute resolved user permissions
	refreshUserResourcePermissions(db)

	elapsed := time.Since(startAll).Truncate(time.Millisecond)
	log.Printf("[postgres] Postgres data import DONE: totalRows=%d elapsed=%s", total, elapsed)
}

// =========================
// CSV helper
// =========================

func openCSV(name string) (*csv.Reader, *os.File) {
	full := filepath.Join(dataDir, name)
	f, err := os.Open(full)
	if err != nil {
		// keep message similar to authzed loader
		if os.IsNotExist(err) {
			log.Printf("[postgres] %s not found, skipping", full)
			return nil, nil
		}
		log.Fatalf("[postgres] open %s: %v", full, err)
	}
	r := csv.NewReader(f)
	return r, f
}

// =========================
// Load functions per table
// =========================

func loadOrganizations(db *sql.DB, total *int) {
	r, f := openCSV("organizations.csv")
	if r == nil {
		log.Printf("[postgres] organizations.csv not found, skipping")
		return
	}
	defer f.Close()

	// organizations.csv: org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[postgres] organizations: read header failed: %v", err)
	}

	tx, err := db.Begin()
	if err != nil {
		log.Fatalf("[postgres] organizations: begin tx failed: %v", err)
	}
	defer tx.Rollback()

	// Use temp table for bulk COPY then upsert
	if _, err := tx.Exec(`CREATE TEMP TABLE staging_organizations (org_id INTEGER) ON COMMIT DROP`); err != nil {
		log.Fatalf("[postgres] organizations: create staging table failed: %v", err)
	}

	stmt, err := tx.Prepare(pq.CopyIn("staging_organizations", "org_id"))
	if err != nil {
		log.Fatalf("[postgres] organizations: prepare CopyIn failed: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[postgres] organizations: read row failed: %v", err)
		}
		if len(rec) < 1 {
			log.Fatalf("[postgres] organizations: invalid row: %#v", rec)
		}

		if _, err := stmt.Exec(rec[0]); err != nil {
			log.Fatalf("[postgres] organizations: CopyIn exec failed: %v", err)
		}
		count++
	}

	if _, err := stmt.Exec(); err != nil {
		log.Fatalf("[postgres] organizations: final CopyIn exec failed: %v", err)
	}
	if err := stmt.Close(); err != nil {
		log.Fatalf("[postgres] organizations: close stmt failed: %v", err)
	}

	// Upsert: insert new rows, update nothing on conflict (PK already exists)
	if _, err := tx.Exec(`INSERT INTO organizations (org_id) SELECT org_id FROM staging_organizations ON CONFLICT (org_id) DO NOTHING`); err != nil {
		log.Fatalf("[postgres] organizations: upsert failed: %v", err)
	}

	if err := tx.Commit(); err != nil {
		log.Fatalf("[postgres] organizations: commit failed: %v", err)
	}

	*total += count
	log.Printf("[postgres] Loaded organizations: %d rows (cumulative=%d)", count, *total)
}

func loadUsers(db *sql.DB, total *int) {
	r, f := openCSV("users.csv")
	if r == nil {
		log.Printf("[postgres] users.csv not found, skipping")
		return
	}
	defer f.Close()

	// users.csv: user_id,org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[postgres] users: read header failed: %v", err)
	}

	tx, err := db.Begin()
	if err != nil {
		log.Fatalf("[postgres] users: begin tx failed: %v", err)
	}
	defer tx.Rollback()

	if _, err := tx.Exec(`CREATE TEMP TABLE staging_users (user_id INTEGER, org_id INTEGER) ON COMMIT DROP`); err != nil {
		log.Fatalf("[postgres] users: create staging table failed: %v", err)
	}

	stmt, err := tx.Prepare(pq.CopyIn("staging_users", "user_id", "org_id"))
	if err != nil {
		log.Fatalf("[postgres] users: prepare CopyIn failed: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[postgres] users: read row failed: %v", err)
		}
		if len(rec) < 2 {
			log.Fatalf("[postgres] users: invalid row: %#v", rec)
		}

		if _, err := stmt.Exec(rec[0], rec[1]); err != nil {
			log.Fatalf("[postgres] users: CopyIn exec failed: %v", err)
		}
		count++
	}

	if _, err := stmt.Exec(); err != nil {
		log.Fatalf("[postgres] users: final CopyIn exec failed: %v", err)
	}
	if err := stmt.Close(); err != nil {
		log.Fatalf("[postgres] users: close stmt failed: %v", err)
	}

	// Upsert: overwrite org_id if user already exists
	if _, err := tx.Exec(`INSERT INTO users (user_id, org_id) SELECT user_id, org_id FROM staging_users ON CONFLICT (user_id) DO UPDATE SET org_id = EXCLUDED.org_id`); err != nil {
		log.Fatalf("[postgres] users: upsert failed: %v", err)
	}

	if err := tx.Commit(); err != nil {
		log.Fatalf("[postgres] users: commit failed: %v", err)
	}

	*total += count
	log.Printf("[postgres] Loaded users: %d rows (cumulative=%d)", count, *total)
}

func loadGroups(db *sql.DB, total *int) {
	r, f := openCSV("groups.csv")
	if r == nil {
		log.Printf("[postgres] groups.csv not found, skipping")
		return
	}
	defer f.Close()

	// groups.csv: group_id,org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[postgres] groups: read header failed: %v", err)
	}

	tx, err := db.Begin()
	if err != nil {
		log.Fatalf("[postgres] groups: begin tx failed: %v", err)
	}
	defer tx.Rollback()

	if _, err := tx.Exec(`CREATE TEMP TABLE staging_groups (group_id INTEGER, org_id INTEGER) ON COMMIT DROP`); err != nil {
		log.Fatalf("[postgres] groups: create staging table failed: %v", err)
	}

	stmt, err := tx.Prepare(pq.CopyIn("staging_groups", "group_id", "org_id"))
	if err != nil {
		log.Fatalf("[postgres] groups: prepare CopyIn failed: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[postgres] groups: read row failed: %v", err)
		}
		if len(rec) < 2 {
			log.Fatalf("[postgres] groups: invalid row: %#v", rec)
		}

		if _, err := stmt.Exec(rec[0], rec[1]); err != nil {
			log.Fatalf("[postgres] groups: CopyIn exec failed: %v", err)
		}
		count++
	}

	if _, err := stmt.Exec(); err != nil {
		log.Fatalf("[postgres] groups: final CopyIn exec failed: %v", err)
	}
	if err := stmt.Close(); err != nil {
		log.Fatalf("[postgres] groups: close stmt failed: %v", err)
	}

	// Upsert: overwrite org_id if group already exists
	if _, err := tx.Exec(`INSERT INTO groups (group_id, org_id) SELECT group_id, org_id FROM staging_groups ON CONFLICT (group_id) DO UPDATE SET org_id = EXCLUDED.org_id`); err != nil {
		log.Fatalf("[postgres] groups: upsert failed: %v", err)
	}

	if err := tx.Commit(); err != nil {
		log.Fatalf("[postgres] groups: commit failed: %v", err)
	}

	*total += count
	log.Printf("[postgres] Loaded groups -> org.member_group: %d rows (cumulative=%d)", count, *total)
}

func loadOrgMemberships(db *sql.DB, total *int) {
	r, f := openCSV("org_memberships.csv")
	if r == nil {
		log.Printf("[postgres] org_memberships.csv not found, skipping")
		return
	}
	defer f.Close()

	// org_memberships.csv: org_id,user_id,role
	if _, err := r.Read(); err != nil {
		log.Fatalf("[postgres] org_memberships: read header failed: %v", err)
	}

	tx, err := db.Begin()
	if err != nil {
		log.Fatalf("[postgres] org_memberships: begin tx failed: %v", err)
	}
	defer tx.Rollback()

	if _, err := tx.Exec(`CREATE TEMP TABLE staging_org_memberships (org_id INTEGER, user_id INTEGER, role TEXT) ON COMMIT DROP`); err != nil {
		log.Fatalf("[postgres] org_memberships: create staging table failed: %v", err)
	}

	stmt, err := tx.Prepare(pq.CopyIn("staging_org_memberships", "org_id", "user_id", "role"))
	if err != nil {
		log.Fatalf("[postgres] org_memberships: prepare CopyIn failed: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[postgres] org_memberships: read row failed: %v", err)
		}
		if len(rec) < 3 {
			log.Fatalf("[postgres] org_memberships: invalid row: %#v", rec)
		}

		if _, err := stmt.Exec(rec[0], rec[1], rec[2]); err != nil {
			log.Fatalf("[postgres] org_memberships: CopyIn exec failed: %v", err)
		}
		count++
	}

	if _, err := stmt.Exec(); err != nil {
		log.Fatalf("[postgres] org_memberships: final CopyIn exec failed: %v", err)
	}
	if err := stmt.Close(); err != nil {
		log.Fatalf("[postgres] org_memberships: close stmt failed: %v", err)
	}

	// Upsert: overwrite role if (org_id, user_id) already exists
	if _, err := tx.Exec(`INSERT INTO org_memberships (org_id, user_id, role) SELECT org_id, user_id, role FROM staging_org_memberships ON CONFLICT (org_id, user_id) DO UPDATE SET role = EXCLUDED.role`); err != nil {
		log.Fatalf("[postgres] org_memberships: upsert failed: %v", err)
	}

	if err := tx.Commit(); err != nil {
		log.Fatalf("[postgres] org_memberships: commit failed: %v", err)
	}

	*total += count
	log.Printf("[postgres] Loaded org_memberships: %d rows (cumulative=%d)", count, *total)
}

func loadGroupMemberships(db *sql.DB, total *int) {
	r, f := openCSV("group_memberships.csv")
	if r == nil {
		log.Printf("[postgres] group_memberships.csv not found, skipping")
		return
	}
	defer f.Close()

	// group_memberships.csv: group_id,user_id,role
	if _, err := r.Read(); err != nil {
		log.Fatalf("[postgres] group_memberships: read header failed: %v", err)
	}

	tx, err := db.Begin()
	if err != nil {
		log.Fatalf("[postgres] group_memberships: begin tx failed: %v", err)
	}
	defer tx.Rollback()

	if _, err := tx.Exec(`CREATE TEMP TABLE staging_group_memberships (group_id INTEGER, user_id INTEGER, role TEXT) ON COMMIT DROP`); err != nil {
		log.Fatalf("[postgres] group_memberships: create staging table failed: %v", err)
	}

	stmt, err := tx.Prepare(pq.CopyIn("staging_group_memberships", "group_id", "user_id", "role"))
	if err != nil {
		log.Fatalf("[postgres] group_memberships: prepare CopyIn failed: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[postgres] group_memberships: read row failed: %v", err)
		}
		if len(rec) < 3 {
			log.Fatalf("[postgres] group_memberships: invalid row: %#v", rec)
		}

		if _, err := stmt.Exec(rec[0], rec[1], rec[2]); err != nil {
			log.Fatalf("[postgres] group_memberships: CopyIn exec failed: %v", err)
		}
		count++
	}

	if _, err := stmt.Exec(); err != nil {
		log.Fatalf("[postgres] group_memberships: final CopyIn exec failed: %v", err)
	}
	if err := stmt.Close(); err != nil {
		log.Fatalf("[postgres] group_memberships: close stmt failed: %v", err)
	}

	// Upsert: overwrite role if (group_id, user_id) already exists
	if _, err := tx.Exec(`INSERT INTO group_memberships (group_id, user_id, role) SELECT group_id, user_id, role FROM staging_group_memberships ON CONFLICT (group_id, user_id) DO UPDATE SET role = EXCLUDED.role`); err != nil {
		log.Fatalf("[postgres] group_memberships: upsert failed: %v", err)
	}

	if err := tx.Commit(); err != nil {
		log.Fatalf("[postgres] group_memberships: commit failed: %v", err)
	}

	*total += count
	log.Printf("[postgres] Loaded group_memberships: %d rows (cumulative=%d)", count, *total)
}

// loadGroupHierarchy loads parent-child group edges from CSV
func loadGroupHierarchy(db *sql.DB, total *int) {
	r, f := openCSV("group_hierarchy.csv")
	if r == nil {
		log.Printf("[postgres] group_hierarchy.csv not found, skipping nested groups")
		return
	}
	defer f.Close()

	// header: parent_group_id,child_group_id,relation
	if _, err := r.Read(); err != nil {
		log.Fatalf("[postgres] group_hierarchy: read header failed: %v", err)
	}

	tx, err := db.Begin()
	if err != nil {
		log.Fatalf("[postgres] group_hierarchy: begin tx failed: %v", err)
	}
	defer tx.Rollback()

	if _, err := tx.Exec(`CREATE TEMP TABLE staging_group_hierarchy (parent_group_id INTEGER, child_group_id INTEGER, relation TEXT) ON COMMIT DROP`); err != nil {
		log.Fatalf("[postgres] group_hierarchy: create staging table failed: %v", err)
	}

	stmt, err := tx.Prepare(pq.CopyIn("staging_group_hierarchy", "parent_group_id", "child_group_id", "relation"))
	if err != nil {
		log.Fatalf("[postgres] group_hierarchy: prepare CopyIn failed: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[postgres] group_hierarchy: read row failed: %v", err)
		}
		if len(rec) < 3 {
			log.Fatalf("[postgres] group_hierarchy: invalid row: %#v", rec)
		}

		if _, err := stmt.Exec(rec[0], rec[1], rec[2]); err != nil {
			log.Fatalf("[postgres] group_hierarchy: CopyIn exec failed: %v", err)
		}
		count++
	}

	if _, err := stmt.Exec(); err != nil {
		log.Fatalf("[postgres] group_hierarchy: final CopyIn exec failed: %v", err)
	}
	if err := stmt.Close(); err != nil {
		log.Fatalf("[postgres] group_hierarchy: close stmt failed: %v", err)
	}

	// Upsert: ignore duplicates (composite PK)
	if _, err := tx.Exec(`INSERT INTO group_hierarchy (parent_group_id, child_group_id, relation) SELECT parent_group_id, child_group_id, relation FROM staging_group_hierarchy ON CONFLICT (parent_group_id, child_group_id, relation) DO NOTHING`); err != nil {
		log.Fatalf("[postgres] group_hierarchy: upsert failed: %v", err)
	}

	if err := tx.Commit(); err != nil {
		log.Fatalf("[postgres] group_hierarchy: commit failed: %v", err)
	}

	*total += count
	log.Printf("[postgres] Loaded group_hierarchy: %d rows (cumulative=%d)", count, *total)
}

func loadResources(db *sql.DB, total *int) {
	r, f := openCSV("resources.csv")
	if r == nil {
		log.Printf("[postgres] resources.csv not found, skipping")
		return
	}
	defer f.Close()

	// resources.csv: resource_id,org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[postgres] resources: read header failed: %v", err)
	}

	tx, err := db.Begin()
	if err != nil {
		log.Fatalf("[postgres] resources: begin tx failed: %v", err)
	}
	defer tx.Rollback()

	if _, err := tx.Exec(`CREATE TEMP TABLE staging_resources (resource_id INTEGER, org_id INTEGER) ON COMMIT DROP`); err != nil {
		log.Fatalf("[postgres] resources: create staging table failed: %v", err)
	}

	stmt, err := tx.Prepare(pq.CopyIn("staging_resources", "resource_id", "org_id"))
	if err != nil {
		log.Fatalf("[postgres] resources: prepare CopyIn failed: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[postgres] resources: read row failed: %v", err)
		}
		if len(rec) < 2 {
			log.Fatalf("[postgres] resources: invalid row: %#v", rec)
		}

		if _, err := stmt.Exec(rec[0], rec[1]); err != nil {
			log.Fatalf("[postgres] resources: CopyIn exec failed: %v", err)
		}
		count++
	}

	if _, err := stmt.Exec(); err != nil {
		log.Fatalf("[postgres] resources: final CopyIn exec failed: %v", err)
	}
	if err := stmt.Close(); err != nil {
		log.Fatalf("[postgres] resources: close stmt failed: %v", err)
	}

	// Upsert: overwrite org_id if resource already exists
	if _, err := tx.Exec(`INSERT INTO resources (resource_id, org_id) SELECT resource_id, org_id FROM staging_resources ON CONFLICT (resource_id) DO UPDATE SET org_id = EXCLUDED.org_id`); err != nil {
		log.Fatalf("[postgres] resources: upsert failed: %v", err)
	}

	if err := tx.Commit(); err != nil {
		log.Fatalf("[postgres] resources: commit failed: %v", err)
	}

	*total += count
	log.Printf("[postgres] Loaded resources -> resource.org: %d rows (cumulative=%d)", count, *total)
}

func loadResourceACL(db *sql.DB, total *int) {
	r, f := openCSV("resource_acl.csv")
	if r == nil {
		log.Printf("[postgres] resource_acl.csv not found, skipping")
		return
	}
	defer f.Close()

	// resource_acl.csv: resource_id,subject_type,subject_id,relation
	if _, err := r.Read(); err != nil {
		log.Fatalf("[postgres] resource_acl: read header failed: %v", err)
	}

	tx, err := db.Begin()
	if err != nil {
		log.Fatalf("[postgres] resource_acl: begin tx failed: %v", err)
	}
	defer tx.Rollback()

	if _, err := tx.Exec(`CREATE TEMP TABLE staging_resource_acl (resource_id INTEGER, subject_type TEXT, subject_id INTEGER, relation TEXT) ON COMMIT DROP`); err != nil {
		log.Fatalf("[postgres] resource_acl: create staging table failed: %v", err)
	}

	stmt, err := tx.Prepare(pq.CopyIn("staging_resource_acl", "resource_id", "subject_type", "subject_id", "relation"))
	if err != nil {
		log.Fatalf("[postgres] resource_acl: prepare CopyIn failed: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[postgres] resource_acl: read row failed: %v", err)
		}
		if len(rec) < 4 {
			log.Fatalf("[postgres] resource_acl: invalid row: %#v", rec)
		}

		if _, err := stmt.Exec(rec[0], rec[1], rec[2], rec[3]); err != nil {
			log.Fatalf("[postgres] resource_acl: CopyIn exec failed: %v", err)
		}
		count++
	}

	if _, err := stmt.Exec(); err != nil {
		log.Fatalf("[postgres] resource_acl: final CopyIn exec failed: %v", err)
	}
	if err := stmt.Close(); err != nil {
		log.Fatalf("[postgres] resource_acl: close stmt failed: %v", err)
	}

	// Upsert: ignore duplicates (composite PK)
	if _, err := tx.Exec(`INSERT INTO resource_acl (resource_id, subject_type, subject_id, relation) SELECT resource_id, subject_type, subject_id, relation FROM staging_resource_acl ON CONFLICT (resource_id, subject_type, subject_id, relation) DO NOTHING`); err != nil {
		log.Fatalf("[postgres] resource_acl: upsert failed: %v", err)
	}

	if err := tx.Commit(); err != nil {
		log.Fatalf("[postgres] resource_acl: commit failed: %v", err)
	}

	*total += count
	log.Printf("[postgres] Loaded resource_acl: %d rows (cumulative=%d)", count, *total)
}

// refreshUserResourcePermissions calls the convenience function in the DB
// that refreshes the materialized view `user_resource_permissions`.
func refreshUserResourcePermissions(db *sql.DB) {
	start := time.Now()
	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
	defer cancel()

	if _, err := db.ExecContext(ctx, `SELECT refresh_user_resource_permissions()`); err != nil {
		log.Fatalf("[postgres] refresh_user_resource_permissions: failed: %v", err)
	}

	log.Printf("[postgres] refresh_user_resource_permissions: DONE in %s", time.Since(start).Truncate(time.Millisecond))
}
