package authzed_pgdb

import (
	"context"
	"encoding/csv"
	"io"
	"log"
	"os"
	"path/filepath"
	"time"

	v1 "github.com/authzed/authzed-go/proto/authzed/api/v1"
	authzed "github.com/authzed/authzed-go/v1"

	"test-tls/infrastructure"
)

const (
	// We now treat CSV as the single source of truth.
	dataDir   = "data"
	batchSize = 1000 // maximize SpiceDB's WriteRelationships limit
)

// Global consistency token caching for deterministic benchmarks
var lastConsistencyToken *v1.ZedToken

// AuthzedCreateData loads the deterministic relational ACL dataset generated by
// cmd/csv/load_data.go into SpiceDB, using schemas.zed as the schema.
func AuthzedCreateData() {
	client, _, cancel, err := infrastructure.NewAuthzedPgdbClientFromEnv(context.Background())

	if err != nil {
		log.Fatalf("[authzed_pgdb] create authzed client: %v", err)
	}
	defer cancel()
	defer client.Close()

	start := time.Now()
	relCount := 0
	batch := make([]*v1.RelationshipUpdate, 0, batchSize)

	log.Printf("[authzed_pgdb] == Starting Authzed data import from CSV in %q ==", dataDir)

	loadOrgMemberships(client, &batch, &relCount, start)
	loadGroups(client, &batch, &relCount, start)
	loadGroupMemberships(client, &batch, &relCount, start)
	loadGroupHierarchy(client, &batch, &relCount, start)
	loadResources(client, &batch, &relCount, start)
	loadResourceACL(client, &batch, &relCount, start)

	// Flush remaining batch
	if len(batch) > 0 {
		writeBatchWithToken(client, batch)
	}

	elapsed := time.Since(start).Truncate(time.Millisecond)
	log.Printf("[authzed_pgdb] Authzed data import DONE: totalRelationships=%d elapsed=%s lastConsistencyToken=%v", relCount, elapsed, lastConsistencyToken)
}

// =========================
// CSV loading helper
// =========================

func openCSV(name string) (*csv.Reader, *os.File) {
	full := filepath.Join(dataDir, name)
	f, err := os.Open(full)
	if err != nil {
		log.Fatalf("[authzed_pgdb] open %s: %v", full, err)
	}
	r := csv.NewReader(f)
	return r, f
}

// We deliberately keep object IDs equal to the CSV IDs (plain decimal strings)
// for 1:1 mapping across backends. If you ever want prefixes like "user42",
// change these helpers consistently.
func orgObjectID(id string) string      { return id }
func userObjectID(id string) string     { return id }
func groupObjectID(id string) string    { return id }
func resourceObjectID(id string) string { return id }

// =========================
// Phase 1: Organizations & org_memberships.csv
// =========================
//
// org_memberships.csv: org_id,user_id,role
//   - role in {"member","admin"}
//   - maps to organization.admin_user / organization.member_user

func loadOrgMemberships(client *authzed.Client, batch *[]*v1.RelationshipUpdate, relCount *int, start time.Time) {
	r, f := openCSV("org_memberships.csv")
	defer f.Close()

	// Skip header
	if _, err := r.Read(); err != nil {
		log.Fatalf("[authzed_pgdb] read org_memberships header: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[authzed_pgdb] read org_memberships row: %v", err)
		}
		if len(rec) < 3 {
			log.Fatalf("[authzed_pgdb] invalid org_memberships row: %#v", rec)
		}

		orgIDRaw := rec[0]
		userIDRaw := rec[1]
		role := rec[2]

		orgID := orgObjectID(orgIDRaw)
		userID := userObjectID(userIDRaw)

		var relation string
		switch role {
		case "admin":
			relation = "admin_user"
		default:
			// treat anything non-admin as member
			relation = "member_user"
		}

		*batch = append(*batch, mkCreateRel(
			"organization", orgID,
			relation,
			"user", userID,
			"",
		))
		*relCount++
		count++
		flushIfNeeded(client, batch, relCount, start)
		if count%10000 == 0 {
			log.Printf("[authzed_pgdb] Loaded org_memberships progress: %d rows (cumulative=%d) elapsed=%s", count, *relCount, time.Since(start).Truncate(time.Millisecond))
		}
	}

	log.Printf("[authzed_pgdb] Loaded org_memberships: %d relationships (cumulative=%d)", count, *relCount)
}

// =========================
// Phase 2: groups.csv -> organization.member_group
// =========================
//
// groups.csv: group_id,org_id
// We model each group as belonging to its organization via member_group,
// using the usergroup#member userset as per schemas.zed:
//
//   relation member_group: usergroup#member
//
// This makes members of those groups count as organization members via
// organization.permission member.

func loadGroups(client *authzed.Client, batch *[]*v1.RelationshipUpdate, relCount *int, start time.Time) {
	r, f := openCSV("groups.csv")
	defer f.Close()

	// header: group_id,org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[authzed_pgdb] read groups header: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[authzed_pgdb] read groups row: %v", err)
		}
		if len(rec) < 2 {
			log.Fatalf("[authzed_pgdb] invalid groups row: %#v", rec)
		}

		groupIDRaw := rec[0]
		orgIDRaw := rec[1]

		groupID := groupObjectID(groupIDRaw)
		orgID := orgObjectID(orgIDRaw)

		// organization#member_group@usergroup:group#member
		*batch = append(*batch, mkCreateRel(
			"organization", orgID,
			"member_group",
			"usergroup", groupID,
			"member",
		))
		*relCount++
		count++
		flushIfNeeded(client, batch, relCount, start)
		if count%10000 == 0 {
			log.Printf("[authzed_pgdb] Loaded groups progress: %d rows (cumulative=%d) elapsed=%s", count, *relCount, time.Since(start).Truncate(time.Millisecond))
		}
	}

	log.Printf("[authzed_pgdb] Loaded groups -> org.member_group: %d relationships (cumulative=%d)", count, *relCount)
}

// =========================
// Phase 3: group_memberships.csv -> usergroup.{direct_member_user,direct_manager_user}
// =========================
//
// group_memberships.csv: group_id,user_id,role
//   - role in {"direct_member","direct_manager"}
//   - direct_member: regular group members
//   - direct_manager: users with manager permissions in group
//   - maps to usergroup.direct_member_user / usergroup.direct_manager_user
//
// Schema 3 distinction:
//   permission member = direct_member_user + member_group->member + manager
//   permission manager = direct_manager_user + manager_group->manager
// Both managers and members get member permission (via permission logic)
// Managers get escalated permissions

func loadGroupMemberships(client *authzed.Client, batch *[]*v1.RelationshipUpdate, relCount *int, start time.Time) {
	r, f := openCSV("group_memberships.csv")
	defer f.Close()

	// header: group_id,user_id,role
	if _, err := r.Read(); err != nil {
		log.Fatalf("[authzed_pgdb] read group_memberships header: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[authzed_pgdb] read group_memberships row: %v", err)
		}
		if len(rec) < 3 {
			log.Fatalf("[authzed_pgdb] invalid group_memberships row: %#v", rec)
		}

		groupIDRaw := rec[0]
		userIDRaw := rec[1]
		role := rec[2]

		groupID := groupObjectID(groupIDRaw)
		userID := userObjectID(userIDRaw)

		// Schema 3: support both direct_member and direct_manager roles
		var relation string
		switch role {
		case "direct_manager":
			relation = "direct_manager_user"
		case "direct_member":
			relation = "direct_member_user"
		default:
			// Backward compat: treat "member" as direct_member, "admin" as direct_manager
			if role == "admin" {
				relation = "direct_manager_user"
			} else {
				relation = "direct_member_user"
			}
		}

		*batch = append(*batch, mkCreateRel(
			"usergroup", groupID,
			relation,
			"user", userID,
			"",
		))
		*relCount++
		count++
		flushIfNeeded(client, batch, relCount, start)
		if count%10000 == 0 {
			log.Printf("[authzed_pgdb] Loaded group_memberships progress: %d rows (cumulative=%d) elapsed=%s", count, *relCount, time.Since(start).Truncate(time.Millisecond))
		}
	}

	log.Printf("[authzed_pgdb] Loaded group_memberships: %d relationships (cumulative=%d)", count, *relCount)
}

// =========================
// Phase 3b: group_hierarchy.csv -> usergroup.{member_group,manager_group}
// =========================
//
// group_hierarchy.csv: parent_group_id,child_group_id,relation
//   - relation in {"member_group","manager_group"}
//   - member_group: child group members are parent group members
//   - manager_group: child group managers are parent group managers
//   - enables nested organizational hierarchies
//
// Schema 3 permission inheritance:
//   permission member = direct_member_user + member_group->member + manager
//   permission manager = direct_manager_user + manager_group->manager
// Users in child groups transitively gain parent group permissions

func loadGroupHierarchy(client *authzed.Client, batch *[]*v1.RelationshipUpdate, relCount *int, start time.Time) {
	r, f := openCSV("group_hierarchy.csv")
	defer f.Close()

	// header: parent_group_id,child_group_id,relation
	if _, err := r.Read(); err != nil {
		// File may not exist if no hierarchy data
		if os.IsNotExist(err) {
			log.Printf("[authzed_pgdb] group_hierarchy.csv not found, skipping nested groups")
			return
		}
		log.Fatalf("[authzed_pgdb] read group_hierarchy header: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[authzed_pgdb] read group_hierarchy row: %v", err)
		}
		if len(rec) < 3 {
			log.Fatalf("[authzed_pgdb] invalid group_hierarchy row: %#v", rec)
		}

		parentGroupIDRaw := rec[0]
		childGroupIDRaw := rec[1]
		hierarchyRelation := rec[2]

		parentGroupID := groupObjectID(parentGroupIDRaw)
		childGroupID := groupObjectID(childGroupIDRaw)

		var relation string
		switch hierarchyRelation {
		case "manager_group":
			relation = "manager_group"
		case "member_group":
			relation = "member_group"
		default:
			log.Fatalf("[authzed_pgdb] unknown group hierarchy relation: %q", hierarchyRelation)
		}

		// usergroup:parent_group#member_group@usergroup:child_group (no userset reference)
		*batch = append(*batch, mkCreateRel(
			"usergroup", parentGroupID,
			relation,
			"usergroup", childGroupID,
			"",
		))
		*relCount++
		count++
		flushIfNeeded(client, batch, relCount, start)
		if count%10000 == 0 {
			log.Printf("[authzed_pgdb] Loaded group_hierarchy progress: %d rows (cumulative=%d) elapsed=%s", count, *relCount, time.Since(start).Truncate(time.Millisecond))
		}
	}

	log.Printf("[authzed_pgdb] Loaded group_hierarchy: %d relationships (cumulative=%d)", count, *relCount)
}

// =========================
// Phase 4: resources.csv -> resource.org
// =========================
//
// resources.csv: resource_id,org_id
// We assign each resource to its owning organization via resource.org.

func loadResources(client *authzed.Client, batch *[]*v1.RelationshipUpdate, relCount *int, start time.Time) {
	r, f := openCSV("resources.csv")
	defer f.Close()

	// header: resource_id,org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[authzed_pgdb] read resources header: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[authzed_pgdb] read resources row: %v", err)
		}
		if len(rec) < 2 {
			log.Fatalf("[authzed_pgdb] invalid resources row: %#v", rec)
		}

		resIDRaw := rec[0]
		orgIDRaw := rec[1]

		resID := resourceObjectID(resIDRaw)
		orgID := orgObjectID(orgIDRaw)

		*batch = append(*batch, mkCreateRel(
			"resource", resID,
			"org",
			"organization", orgID,
			"",
		))
		*relCount++
		count++
		flushIfNeeded(client, batch, relCount, start)
		if count%10000 == 0 {
			log.Printf("[authzed_pgdb] Loaded resources -> resource.org: %d relationships (cumulative=%d) elapsed=%s", count, *relCount, time.Since(start).Truncate(time.Millisecond))
		}
	}

	log.Printf("[authzed_pgdb] Loaded resources -> resource.org: %d relationships (cumulative=%d)", count, *relCount)
}

// =========================
// Phase 5: resource_acl.csv -> resource.*
// =========================
//
// resource_acl.csv: resource_id,subject_type,subject_id,relation
//   - subject_type in {"user","group"}
//   - relation in {"manager_user","viewer_user","manager_group","viewer_group"}
//
// Schema 3 mapping to schemas.zed:
//   - user + manager_user -> resource.manager_user@user
//   - user + viewer_user -> resource.viewer_user@user
//   - group + manager_group -> resource.manager_group@usergroup#manager
//   - group + viewer_group -> resource.viewer_group@usergroup#member
//
// Permission inheritance:
//   permission manage = manager_user + manager_group + org->admin
//     (managers from direct assignment or group manager role)
//   permission view = viewer_user + viewer_group + manage + org->member
//     (viewers + managers can view, plus org members)
//
// Key benefit: explicit user/group split enables clear auditability
// of who can do what without ambiguity

func loadResourceACL(client *authzed.Client, batch *[]*v1.RelationshipUpdate, relCount *int, start time.Time) {
	r, f := openCSV("resource_acl.csv")
	defer f.Close()

	// header: resource_id,subject_type,subject_id,relation
	if _, err := r.Read(); err != nil {
		log.Fatalf("[authzed_pgdb] read resource_acl header: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[authzed_pgdb] read resource_acl row: %v", err)
		}
		if len(rec) < 4 {
			log.Fatalf("[authzed_pgdb] invalid resource_acl row: %#v", rec)
		}

		resIDRaw := rec[0]
		subjectType := rec[1]
		subjectIDRaw := rec[2]
		aclRelation := rec[3]

		resID := resourceObjectID(resIDRaw)

		switch subjectType {
		case "user":
			userID := userObjectID(subjectIDRaw)

			switch aclRelation {
			case "manager_user":
				*batch = append(*batch, mkCreateRel(
					"resource", resID,
					"manager_user",
					"user", userID,
					"",
				))
			case "viewer_user":
				*batch = append(*batch, mkCreateRel(
					"resource", resID,
					"viewer_user",
					"user", userID,
					"",
				))
			// Backward compat: old schema used "manager", "viewer"
			case "manager":
				*batch = append(*batch, mkCreateRel(
					"resource", resID,
					"manager_user",
					"user", userID,
					"",
				))
			case "viewer":
				*batch = append(*batch, mkCreateRel(
					"resource", resID,
					"viewer_user",
					"user", userID,
					"",
				))
			default:
				log.Fatalf("[authzed_pgdb] unknown ACL relation for user: %q", aclRelation)
			}

		case "group":
			groupID := groupObjectID(subjectIDRaw)

			switch aclRelation {
			case "manager_group":
				// resource.manager_group: usergroup#manager (Schema 3)
				*batch = append(*batch, mkCreateRel(
					"resource", resID,
					"manager_group",
					"usergroup", groupID,
					"manager",
				))
			case "viewer_group":
				// resource.viewer_group: usergroup#member (Schema 3)
				*batch = append(*batch, mkCreateRel(
					"resource", resID,
					"viewer_group",
					"usergroup", groupID,
					"member",
				))
			// Backward compat: old schema used "manager", "viewer"
			case "manager":
				*batch = append(*batch, mkCreateRel(
					"resource", resID,
					"manager_group",
					"usergroup", groupID,
					"manager",
				))
			case "viewer":
				*batch = append(*batch, mkCreateRel(
					"resource", resID,
					"viewer_group",
					"usergroup", groupID,
					"member",
				))
			default:
				log.Fatalf("[authzed_pgdb] unknown ACL relation for group: %q", aclRelation)
			}

		default:
			log.Fatalf("[authzed_pgdb] unknown subject_type in resource_acl: %q", subjectType)
		}

		*relCount++
		count++
		flushIfNeeded(client, batch, relCount, start)
		if count%10000 == 0 {
			log.Printf("[authzed_pgdb] Loaded resource_acl progress: %d rows (cumulative=%d) elapsed=%s", count, *relCount, time.Since(start).Truncate(time.Millisecond))
		}
	}

	log.Printf("[authzed_pgdb] Loaded resource_acl: %d relationships (cumulative=%d)", count, *relCount)
}

// ============================
// Helpers (unchanged semantics)
// ============================

func mkCreateRel(
	resType, resID, relation string,
	subjectType, subjectID, subjectRel string,
) *v1.RelationshipUpdate {
	return &v1.RelationshipUpdate{
		Operation: v1.RelationshipUpdate_OPERATION_TOUCH,
		Relationship: &v1.Relationship{
			Resource: &v1.ObjectReference{
				ObjectType: resType,
				ObjectId:   resID,
			},
			Relation: relation,
			Subject: &v1.SubjectReference{
				Object: &v1.ObjectReference{
					ObjectType: subjectType,
					ObjectId:   subjectID,
				},
				OptionalRelation: subjectRel,
			},
		},
	}
}

func flushIfNeeded(client *authzed.Client, batch *[]*v1.RelationshipUpdate, relCount *int, start time.Time) {
	if len(*batch) < batchSize {
		return
	}
	writeBatchWithToken(client, *batch)
	*batch = (*batch)[:0]

	if (*relCount)%1_000_000 == 0 {
		log.Printf("[authzed_pgdb] ... %d relationships inserted (elapsed=%s)",
			*relCount, time.Since(start).Truncate(time.Millisecond))
	}
}

func writeBatchWithToken(client *authzed.Client, batch []*v1.RelationshipUpdate) {
	ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
	defer cancel()

	resp, err := client.WriteRelationships(ctx, &v1.WriteRelationshipsRequest{
		Updates: batch,
	})
	if err != nil {
		// Log error but don't fatal - some relations may already exist (idempotent)
		log.Printf("[authzed_pgdb] WriteRelationships error (may be duplicate/constraint): %v", err)
		return
	}

	// Cache the latest consistency token for use in benchmarks
	if resp.WrittenAt != nil {
		lastConsistencyToken = resp.WrittenAt
	}
}

// GetLastConsistencyToken returns the last write's consistency token for use in
// benchmark queries to ensure read-after-write consistency.
func GetLastConsistencyToken() *v1.ZedToken {
	return lastConsistencyToken
}
