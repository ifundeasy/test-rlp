package mongodb

import (
	"context"
	"encoding/csv"
	"io"
	"log"
	"os"
	"path/filepath"
	"time"

	"test-tls/infrastructure"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

const (
	dataDir         = "data"
	insertBatchSize = 1000
)

// small set helper
type stringSet map[string]struct{}

func (s stringSet) add(v string) {
	s[v] = struct{}{}
}

func (s stringSet) has(v string) bool {
	_, ok := s[v]
	return ok
}

// MongoCreateData loads the deterministic relational ACL dataset generated by
// cmd/csv/load_data.go into MongoDB, and additionally builds a fully
// denormalized user_resource_perms collection optimized for read benchmarks.
//
// CSV files:
//
//	organizations.csv:     org_id
//	users.csv:             user_id,org_id
//	groups.csv:            group_id,org_id
//	org_memberships.csv:   org_id,user_id,role        // role in {member,admin}
//	group_memberships.csv: group_id,user_id,role      // role currently always "member"
//	resources.csv:         resource_id,org_id
//	resource_acl.csv:      resource_id,subject_type,subject_id,relation
//
// Denormalized collection (Mongo-optimized):
//
//	user_resource_perms: { user_id, resource_id, can_manage, can_view }
//
// Semantics compiled:
//
//	can_manage(user, resource) =
//	  direct manager_user
//	  OR via manager_groups
//	  OR via org admin
//
//	can_view(user, resource) =
//	  can_manage
//	  OR direct viewer_user
//	  OR via viewer_groups
//	  OR via org member
func MongodbCreateData() {
	ctx := context.Background()

	_, db, cleanup, err := infrastructure.NewMongoFromEnv(ctx)
	if err != nil {
		log.Fatalf("[mongodb] failed to create mongo client: %v", err)
	}
	defer cleanup()

	start := time.Now()
	log.Printf("[mongodb] == Loading MongoDB data from CSV in %q ==", dataDir)

	// Clear collections so this run is idempotent.
	clearCollections(ctx, db)

	// Load normalized collections + build auxiliary maps for permissions.
	loadOrganizations(ctx, db)
	loadUsers(ctx, db)
	loadGroups(ctx, db)

	orgAdmins, orgMembers := loadOrgMemberships(ctx, db)
	groupMembers := loadGroupMemberships(ctx, db)
	resourceOrg := loadResources(ctx, db)
	directUserManagers, directUserViewers, groupManagers, groupViewers := loadResourceACL(ctx, db)

	// Build denormalized `user_resource_perms` from the auxiliary maps.
	buildUserResourcePerms(
		ctx,
		db,
		resourceOrg,
		orgAdmins,
		orgMembers,
		groupMembers,
		directUserManagers,
		directUserViewers,
		groupManagers,
		groupViewers,
	)

	elapsed := time.Since(start).Truncate(time.Millisecond)
	log.Printf("[mongodb] MongoDB data load DONE: elapsed=%s", elapsed)
}

// =========================
// Collection clearing
// =========================

func clearCollections(ctx context.Context, db *mongo.Database) {
	names := []string{
		"organizations",
		"users",
		"groups",
		"org_memberships",
		"group_memberships",
		"resources",
		"resource_acl",
		"user_resource_perms",
	}

	for _, name := range names {
		coll := db.Collection(name)
		ctxTimeout, cancel := context.WithTimeout(ctx, 60*time.Second)
		_, err := coll.DeleteMany(ctxTimeout, bson.D{})
		cancel()
		if err != nil {
			log.Fatalf("[mongodb] failed to clear collection %s: %v", name, err)
		}
		log.Printf("[mongodb] Cleared collection: %s", name)
	}
}

// =========================
// CSV helper
// =========================

func openCSV(name string) (*csv.Reader, *os.File) {
	full := filepath.Join(dataDir, name)
	f, err := os.Open(full)
	if err != nil {
		log.Fatalf("[mongodb] open %s: %v", full, err)
	}
	r := csv.NewReader(f)
	return r, f
}

func flushInsertBatch(ctx context.Context, coll *mongo.Collection, batch []interface{}, collName string) int {
	if len(batch) == 0 {
		return 0
	}
	ctxTimeout, cancel := context.WithTimeout(ctx, 120*time.Second)
	defer cancel()

	_, err := coll.InsertMany(ctxTimeout, batch, options.InsertMany().SetOrdered(false))
	if err != nil {
		log.Fatalf("[mongodb] InsertMany into %s failed: %v", collName, err)
	}
	return len(batch)
}

// =========================
// Load organizations
// =========================
//
// organizations.csv: org_id
// Mongo: organizations { _id: org_id }

func loadOrganizations(ctx context.Context, db *mongo.Database) {
	r, f := openCSV("organizations.csv")
	defer f.Close()

	// header: org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[mongodb] read organizations header: %v", err)
	}

	coll := db.Collection("organizations")
	batch := make([]interface{}, 0, insertBatchSize)
	total := 0

	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[mongodb] read organizations row: %v", err)
		}
		if len(rec) < 1 {
			log.Fatalf("[mongodb] invalid organizations row: %#v", rec)
		}
		orgID := rec[0]

		doc := bson.D{{Key: "_id", Value: orgID}}
		batch = append(batch, doc)
		if len(batch) >= insertBatchSize {
			total += flushInsertBatch(ctx, coll, batch, "organizations")
			batch = batch[:0]
		}
	}
	if len(batch) > 0 {
		total += flushInsertBatch(ctx, coll, batch, "organizations")
	}
	log.Printf("[mongodb] Loaded organizations: %d documents", total)
}

// =========================
// Load users
// =========================
//
// users.csv: user_id,org_id
// Mongo: users { _id: user_id, org_id }

func loadUsers(ctx context.Context, db *mongo.Database) {
	r, f := openCSV("users.csv")
	defer f.Close()

	// header: user_id,org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[mongodb] read users header: %v", err)
	}

	coll := db.Collection("users")
	batch := make([]interface{}, 0, insertBatchSize)
	total := 0

	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[mongodb] read users row: %v", err)
		}
		if len(rec) < 2 {
			log.Fatalf("[mongodb] invalid users row: %#v", rec)
		}

		userID := rec[0]
		orgID := rec[1]

		doc := bson.D{
			{Key: "_id", Value: userID},
			{Key: "org_id", Value: orgID},
		}
		batch = append(batch, doc)
		if len(batch) >= insertBatchSize {
			total += flushInsertBatch(ctx, coll, batch, "users")
			batch = batch[:0]
		}
	}
	if len(batch) > 0 {
		total += flushInsertBatch(ctx, coll, batch, "users")
	}
	log.Printf("[mongodb] Loaded users: %d documents", total)
}

// =========================
// Load groups
// =========================
//
// groups.csv: group_id,org_id
// Mongo: groups { _id: group_id, org_id }

func loadGroups(ctx context.Context, db *mongo.Database) {
	r, f := openCSV("groups.csv")
	defer f.Close()

	// header: group_id,org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[mongodb] read groups header: %v", err)
	}

	coll := db.Collection("groups")
	batch := make([]interface{}, 0, insertBatchSize)
	total := 0

	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[mongodb] read groups row: %v", err)
		}
		if len(rec) < 2 {
			log.Fatalf("[mongodb] invalid groups row: %#v", rec)
		}

		groupID := rec[0]
		orgID := rec[1]

		doc := bson.D{
			{Key: "_id", Value: groupID},
			{Key: "org_id", Value: orgID},
		}
		batch = append(batch, doc)
		if len(batch) >= insertBatchSize {
			total += flushInsertBatch(ctx, coll, batch, "groups")
			batch = batch[:0]
		}
	}
	if len(batch) > 0 {
		total += flushInsertBatch(ctx, coll, batch, "groups")
	}
	log.Printf("[mongodb] Loaded groups: %d documents", total)
}

// =========================
// Load org_memberships
// =========================
//
// org_memberships.csv: org_id,user_id,role
//   role in {member,admin}
//
// Mongo: org_memberships { org_id, user_id, role }
//
// Also builds maps:
//   orgAdmins[orgID]  -> set of userID
//   orgMembers[orgID] -> set of userID

func loadOrgMemberships(ctx context.Context, db *mongo.Database) (map[string]stringSet, map[string]stringSet) {
	r, f := openCSV("org_memberships.csv")
	defer f.Close()

	// header: org_id,user_id,role
	if _, err := r.Read(); err != nil {
		log.Fatalf("[mongodb] read org_memberships header: %v", err)
	}

	coll := db.Collection("org_memberships")
	batch := make([]interface{}, 0, insertBatchSize)
	total := 0

	orgAdmins := make(map[string]stringSet)
	orgMembers := make(map[string]stringSet)

	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[mongodb] read org_memberships row: %v", err)
		}
		if len(rec) < 3 {
			log.Fatalf("[mongodb] invalid org_memberships row: %#v", rec)
		}

		orgID := rec[0]
		userID := rec[1]
		role := rec[2]

		doc := bson.D{
			{Key: "org_id", Value: orgID},
			{Key: "user_id", Value: userID},
			{Key: "role", Value: role},
		}
		batch = append(batch, doc)
		if len(batch) >= insertBatchSize {
			total += flushInsertBatch(ctx, coll, batch, "org_memberships")
			batch = batch[:0]
		}

		// Build maps.
		switch role {
		case "admin":
			s, ok := orgAdmins[orgID]
			if !ok {
				s = make(stringSet)
				orgAdmins[orgID] = s
			}
			s.add(userID)
			fallthrough
		default:
			// treat anything (including "admin") as member too
			s, ok := orgMembers[orgID]
			if !ok {
				s = make(stringSet)
				orgMembers[orgID] = s
			}
			s.add(userID)
		}
	}
	if len(batch) > 0 {
		total += flushInsertBatch(ctx, coll, batch, "org_memberships")
	}
	log.Printf("[mongodb] Loaded org_memberships: %d documents", total)

	return orgAdmins, orgMembers
}

// =========================
// Load group_memberships
// =========================
//
// group_memberships.csv: group_id,user_id,role
//   role currently always "member"
//
// Mongo: group_memberships { group_id, user_id, role }
//
// Also builds map:
//   groupMembers[groupID] -> set of userID

func loadGroupMemberships(ctx context.Context, db *mongo.Database) map[string]stringSet {
	r, f := openCSV("group_memberships.csv")
	defer f.Close()

	// header: group_id,user_id,role
	if _, err := r.Read(); err != nil {
		log.Fatalf("[mongodb] read group_memberships header: %v", err)
	}

	coll := db.Collection("group_memberships")
	batch := make([]interface{}, 0, insertBatchSize)
	total := 0

	groupMembers := make(map[string]stringSet)

	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[mongodb] read group_memberships row: %v", err)
		}
		if len(rec) < 3 {
			log.Fatalf("[mongodb] invalid group_memberships row: %#v", rec)
		}

		groupID := rec[0]
		userID := rec[1]
		role := rec[2]

		doc := bson.D{
			{Key: "group_id", Value: groupID},
			{Key: "user_id", Value: userID},
			{Key: "role", Value: role},
		}
		batch = append(batch, doc)
		if len(batch) >= insertBatchSize {
			total += flushInsertBatch(ctx, coll, batch, "group_memberships")
			batch = batch[:0]
		}

		s, ok := groupMembers[groupID]
		if !ok {
			s = make(stringSet)
			groupMembers[groupID] = s
		}
		s.add(userID)
	}
	if len(batch) > 0 {
		total += flushInsertBatch(ctx, coll, batch, "group_memberships")
	}
	log.Printf("[mongodb] Loaded group_memberships: %d documents", total)

	return groupMembers
}

// =========================
// Load resources
// =========================
//
// resources.csv: resource_id,org_id
// Mongo: resources { _id: resource_id, org_id }
//
// Also builds map:
//   resourceOrg[resourceID] -> orgID

func loadResources(ctx context.Context, db *mongo.Database) map[string]string {
	r, f := openCSV("resources.csv")
	defer f.Close()

	// header: resource_id,org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[mongodb] read resources header: %v", err)
	}

	coll := db.Collection("resources")
	batch := make([]interface{}, 0, insertBatchSize)
	total := 0

	resourceOrg := make(map[string]string)

	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[mongodb] read resources row: %v", err)
		}
		if len(rec) < 2 {
			log.Fatalf("[mongodb] invalid resources row: %#v", rec)
		}

		resID := rec[0]
		orgID := rec[1]

		doc := bson.D{
			{Key: "_id", Value: resID},
			{Key: "org_id", Value: orgID},
		}
		batch = append(batch, doc)
		if len(batch) >= insertBatchSize {
			total += flushInsertBatch(ctx, coll, batch, "resources")
			batch = batch[:0]
		}

		resourceOrg[resID] = orgID
	}
	if len(batch) > 0 {
		total += flushInsertBatch(ctx, coll, batch, "resources")
	}
	log.Printf("[mongodb] Loaded resources: %d documents", total)

	return resourceOrg
}

// =========================
// Load resource_acl
// =========================
//
// resource_acl.csv: resource_id,subject_type,subject_id,relation
//   subject_type in {"user","group"}
//   relation in {"manager","viewer"}
//
// Mongo: resource_acl { resource_id, subject_type, subject_id, relation }
//
// Also builds maps:

//   directUserManagers[resourceID] -> set of userID
//   directUserViewers[resourceID]  -> set of userID
//   groupManagers[resourceID]      -> set of groupID
//   groupViewers[resourceID]       -> set of groupID

func loadResourceACL(
	ctx context.Context,
	db *mongo.Database,
) (map[string]stringSet, map[string]stringSet, map[string]stringSet, map[string]stringSet) {
	r, f := openCSV("resource_acl.csv")
	defer f.Close()

	// header: resource_id,subject_type,subject_id,relation
	if _, err := r.Read(); err != nil {
		log.Fatalf("[mongodb] read resource_acl header: %v", err)
	}

	coll := db.Collection("resource_acl")
	batch := make([]interface{}, 0, insertBatchSize)
	total := 0

	directUserManagers := make(map[string]stringSet)
	directUserViewers := make(map[string]stringSet)
	groupManagers := make(map[string]stringSet)
	groupViewers := make(map[string]stringSet)

	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[mongodb] read resource_acl row: %v", err)
		}
		if len(rec) < 4 {
			log.Fatalf("[mongodb] invalid resource_acl row: %#v", rec)
		}

		resID := rec[0]
		subjectType := rec[1]
		subjectID := rec[2]
		relation := rec[3]

		doc := bson.D{
			{Key: "resource_id", Value: resID},
			{Key: "subject_type", Value: subjectType},
			{Key: "subject_id", Value: subjectID},
			{Key: "relation", Value: relation},
		}
		batch = append(batch, doc)
		if len(batch) >= insertBatchSize {
			total += flushInsertBatch(ctx, coll, batch, "resource_acl")
			batch = batch[:0]
		}

		switch subjectType {
		case "user":
			switch relation {
			case "manager":
				s, ok := directUserManagers[resID]
				if !ok {
					s = make(stringSet)
					directUserManagers[resID] = s
				}
				s.add(subjectID)
			case "viewer":
				s, ok := directUserViewers[resID]
				if !ok {
					s = make(stringSet)
					directUserViewers[resID] = s
				}
				s.add(subjectID)
			default:
				log.Fatalf("[mongodb] unknown ACL relation for user: %q", relation)
			}

		case "group":
			switch relation {
			case "manager":
				s, ok := groupManagers[resID]
				if !ok {
					s = make(stringSet)
					groupManagers[resID] = s
				}
				s.add(subjectID)
			case "viewer":
				s, ok := groupViewers[resID]
				if !ok {
					s = make(stringSet)
					groupViewers[resID] = s
				}
				s.add(subjectID)
			default:
				log.Fatalf("[mongodb] unknown ACL relation for group: %q", relation)
			}

		default:
			log.Fatalf("[mongodb] unknown subject_type in resource_acl: %q", subjectType)
		}
	}
	if len(batch) > 0 {
		total += flushInsertBatch(ctx, coll, batch, "resource_acl")
	}
	log.Printf("[mongodb] Loaded resource_acl: %d documents", total)

	return directUserManagers, directUserViewers, groupManagers, groupViewers
}

// =========================
// Build user_resource_perms
// =========================
//
// user_resource_perms: { user_id, resource_id, can_manage, can_view }
//
// can_manage(user, resource) =
//   direct manager_user
//   OR via manager_groups
//   OR via org admin
//
// can_view(user, resource) =
//   can_manage
//   OR direct viewer_user
//   OR via viewer_groups
//   OR via org member

func buildUserResourcePerms(
	ctx context.Context,
	db *mongo.Database,
	resourceOrg map[string]string,
	orgAdmins map[string]stringSet,
	orgMembers map[string]stringSet,
	groupMembers map[string]stringSet,
	directUserManagers map[string]stringSet,
	directUserViewers map[string]stringSet,
	groupManagers map[string]stringSet,
	groupViewers map[string]stringSet,
) {
	coll := db.Collection("user_resource_perms")

	batch := make([]interface{}, 0, insertBatchSize)
	total := 0

	for resID, orgID := range resourceOrg {
		manageUsers := make(stringSet)
		viewUsers := make(stringSet)

		// 1) direct manager users
		if managers, ok := directUserManagers[resID]; ok {
			for u := range managers {
				manageUsers.add(u)
			}
		}

		// 2) managers via groups
		if mgrGroups, ok := groupManagers[resID]; ok {
			for g := range mgrGroups {
				if members, ok := groupMembers[g]; ok {
					for u := range members {
						manageUsers.add(u)
					}
				}
			}
		}

		// 3) org admins
		if admins, ok := orgAdmins[orgID]; ok {
			for u := range admins {
				manageUsers.add(u)
			}
		}

		// 4) viewUsers starts as manageUsers
		for u := range manageUsers {
			viewUsers.add(u)
		}

		// 5) direct viewers
		if viewers, ok := directUserViewers[resID]; ok {
			for u := range viewers {
				viewUsers.add(u)
			}
		}

		// 6) viewer groups
		if vGroups, ok := groupViewers[resID]; ok {
			for g := range vGroups {
				if members, ok := groupMembers[g]; ok {
					for u := range members {
						viewUsers.add(u)
					}
				}
			}
		}

		// 7) org members
		if members, ok := orgMembers[orgID]; ok {
			for u := range members {
				viewUsers.add(u)
			}
		}

		if len(viewUsers) == 0 && len(manageUsers) == 0 {
			continue
		}

		for u := range viewUsers {
			_, canManage := manageUsers[u]

			doc := bson.D{
				{Key: "user_id", Value: u},
				{Key: "resource_id", Value: resID},
				{Key: "can_manage", Value: canManage},
				{Key: "can_view", Value: true},
			}

			batch = append(batch, doc)
			if len(batch) >= insertBatchSize {
				total += flushInsertBatch(ctx, coll, batch, "user_resource_perms")
				batch = batch[:0]
			}
		}
	}

	if len(batch) > 0 {
		total += flushInsertBatch(ctx, coll, batch, "user_resource_perms")
	}

	log.Printf("[mongodb] Loaded user_resource_perms: %d documents", total)
}
