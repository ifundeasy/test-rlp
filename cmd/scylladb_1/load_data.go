package scylladb_1

import (
	"context"
	"encoding/csv"
	"io"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"time"

	"github.com/gocql/gocql"

	"test-tls/infrastructure"
)

const (
	dataDir = "data"
)

// small int-set helper
type intSet map[int]struct{}

func (s intSet) add(v int) {
	s[v] = struct{}{}
}

func (s intSet) has(v int) bool {
	_, ok := s[v]
	return ok
}

// ScylladbCreateData loads the deterministic relational ACL dataset generated by
// cmd/csv/load_data.go into ScyllaDB, and additionally builds fully
// denormalized permission tables optimized for RLS check and list:
//
//   - user_resource_perms_by_user
//   - user_resource_perms_by_resource
//
// CSV files (same as Postgres/Mongo):
//
//	organizations.csv:     org_id
//	users.csv:             user_id,org_id
//	groups.csv:            group_id,org_id
//	org_memberships.csv:   org_id,user_id,role        // role in {member,admin}
//	group_memberships.csv: group_id,user_id,role      // role currently always "member"
//	resources.csv:         resource_id,org_id
//	resource_acl.csv:      resource_id,subject_type,subject_id,relation
//
// Permission semantics compiled:
//
//	can_manage(user, resource) =
//	  direct manager_user
//	  OR via manager_groups
//	  OR via org admin
//
//	can_view(user, resource) =
//	  can_manage
//	  OR direct viewer_user
//	  OR via viewer_groups
//	  OR via org member
func ScylladbCreateData() {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Minute)
	defer cancel()

	session, cleanup, err := infrastructure.NewScyllaFromEnv(ctx)
	if err != nil {
		log.Fatalf("[scylladb_1] NewScyllaFromEnv failed: %v", err)
	}
	defer cleanup()

	start := time.Now()
	log.Printf("[scylladb_1] == Loading CSV data into ScyllaDB ==")

	clearTables(session)

	loadOrganizations(ctx, session)
	loadUsers(ctx, session)
	loadGroups(ctx, session)

	orgAdmins, orgMembers := loadOrgMemberships(ctx, session)
	groupMembers := loadGroupMemberships(ctx, session)
	resourceOrg := loadResources(ctx, session)
	directUserManagers, directUserViewers, groupManagers, groupViewers := loadResourceACL(ctx, session)

	buildUserResourcePerms(
		ctx,
		session,
		resourceOrg,
		orgAdmins,
		orgMembers,
		groupMembers,
		directUserManagers,
		directUserViewers,
		groupManagers,
		groupViewers,
	)

	elapsed := time.Since(start).Truncate(time.Second)
	log.Printf("[scylladb_1] ScyllaDB data load DONE: elapsed=%s", elapsed)
}

// =========================
// Table clearing
// =========================

func clearTables(session *gocql.Session) {
	tables := []string{
		"organizations",
		"users",
		"groups",
		"org_memberships",
		"group_memberships",
		"resources",
		"resource_acl_by_resource",
		"resource_acl_by_subject",
		"user_resource_perms_by_user",
		"user_resource_perms_by_resource",
	}

	for _, tbl := range tables {
		if err := session.Query("TRUNCATE " + tbl).Exec(); err != nil {
			log.Fatalf("[scylladb_1] TRUNCATE %s failed: %v", tbl, err)
		}
		log.Printf("[scylladb_1] Truncated %s", tbl)
	}
}

// =========================
// CSV helpers
// =========================

func openCSV(name string) (*csv.Reader, *os.File) {
	full := filepath.Join(dataDir, name)
	f, err := os.Open(full)
	if err != nil {
		log.Fatalf("[scylladb_1] open %s: %v", full, err)
	}
	r := csv.NewReader(f)
	return r, f
}

func mustAtoi(s, field string) int {
	v, err := strconv.Atoi(s)
	if err != nil {
		log.Fatalf("[scylladb_1] parse int for %s %q failed: %v", field, s, err)
	}
	return v
}

// =========================
// Load organizations
// =========================

func loadOrganizations(ctx context.Context, session *gocql.Session) {
	r, f := openCSV("organizations.csv")
	defer f.Close()

	// header: org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[scylladb_1] read organizations header: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[scylladb_1] organizations: read row failed: %v", err)
		}
		if len(rec) < 1 {
			log.Fatalf("[scylladb_1] organizations: invalid row: %#v", rec)
		}

		orgID := mustAtoi(rec[0], "organizations.org_id")

		if err := session.
			Query("INSERT INTO organizations (org_id) VALUES (?)", orgID).
			WithContext(ctx).
			Exec(); err != nil {
			log.Fatalf("[scylladb_1] organizations: insert failed: %v", err)
		}
		count++
	}

	log.Printf("[scylladb_1] organizations: inserted %d rows", count)
}

// =========================
// Load users
// =========================

func loadUsers(ctx context.Context, session *gocql.Session) {
	r, f := openCSV("users.csv")
	defer f.Close()

	// header: user_id,org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[scylladb_1] read users header: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[scylladb_1] users: read row failed: %v", err)
		}
		if len(rec) < 2 {
			log.Fatalf("[scylladb_1] users: invalid row: %#v", rec)
		}

		userID := mustAtoi(rec[0], "users.user_id")
		orgID := mustAtoi(rec[1], "users.org_id")

		if err := session.
			Query("INSERT INTO users (user_id, org_id) VALUES (?, ?)", userID, orgID).
			WithContext(ctx).
			Exec(); err != nil {
			log.Fatalf("[scylladb_1] users: insert failed: %v", err)
		}
		count++
	}

	log.Printf("[scylladb_1] users: inserted %d rows", count)
}

// =========================
// Load groups
// =========================

func loadGroups(ctx context.Context, session *gocql.Session) {
	r, f := openCSV("groups.csv")
	defer f.Close()

	// header: group_id,org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[scylladb_1] read groups header: %v", err)
	}

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[scylladb_1] groups: read row failed: %v", err)
		}
		if len(rec) < 2 {
			log.Fatalf("[scylladb_1] groups: invalid row: %#v", rec)
		}

		groupID := mustAtoi(rec[0], "groups.group_id")
		orgID := mustAtoi(rec[1], "groups.org_id")

		if err := session.
			Query("INSERT INTO groups (group_id, org_id) VALUES (?, ?)", groupID, orgID).
			WithContext(ctx).
			Exec(); err != nil {
			log.Fatalf("[scylladb_1] groups: insert failed: %v", err)
		}
		count++
	}

	log.Printf("[scylladb_1] groups: inserted %d rows", count)
}

// =========================
// Load org_memberships
// =========================
//
// org_memberships.csv: org_id,user_id,role
//
// Also builds maps:
//
//	orgAdmins[orgID]  -> set of userID
//	orgMembers[orgID] -> set of userID
func loadOrgMemberships(ctx context.Context, session *gocql.Session) (map[int]intSet, map[int]intSet) {
	r, f := openCSV("org_memberships.csv")
	defer f.Close()

	// header: org_id,user_id,role
	if _, err := r.Read(); err != nil {
		log.Fatalf("[scylladb_1] read org_memberships header: %v", err)
	}

	orgAdmins := make(map[int]intSet)
	orgMembers := make(map[int]intSet)

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[scylladb_1] org_memberships: read row failed: %v", err)
		}
		if len(rec) < 3 {
			log.Fatalf("[scylladb_1] org_memberships: invalid row: %#v", rec)
		}

		orgID := mustAtoi(rec[0], "org_memberships.org_id")
		userID := mustAtoi(rec[1], "org_memberships.user_id")
		role := rec[2]

		if err := session.
			Query("INSERT INTO org_memberships (org_id, user_id, role) VALUES (?, ?, ?)", orgID, userID, role).
			WithContext(ctx).
			Exec(); err != nil {
			log.Fatalf("[scylladb_1] org_memberships: insert failed: %v", err)
		}
		count++

		switch role {
		case "admin":
			s, ok := orgAdmins[orgID]
			if !ok {
				s = make(intSet)
				orgAdmins[orgID] = s
			}
			s.add(userID)
		case "member":
			s, ok := orgMembers[orgID]
			if !ok {
				s = make(intSet)
				orgMembers[orgID] = s
			}
			s.add(userID)
		default:
			log.Fatalf("[scylladb_1] org_memberships: unknown role %q", role)
		}
	}

	log.Printf("[scylladb_1] org_memberships: inserted %d rows", count)
	return orgAdmins, orgMembers
}

// =========================
// Load group_memberships
// =========================
//
// group_memberships.csv: group_id,user_id,role
//
// Builds:
//
//	groupMembers[groupID] -> set of userID
func loadGroupMemberships(ctx context.Context, session *gocql.Session) map[int]intSet {
	r, f := openCSV("group_memberships.csv")
	defer f.Close()

	// header: group_id,user_id,role
	if _, err := r.Read(); err != nil {
		log.Fatalf("[scylladb_1] read group_memberships header: %v", err)
	}

	groupMembers := make(map[int]intSet)

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[scylladb_1] group_memberships: read row failed: %v", err)
		}
		if len(rec) < 3 {
			log.Fatalf("[scylladb_1] group_memberships: invalid row: %#v", rec)
		}

		groupID := mustAtoi(rec[0], "group_memberships.group_id")
		userID := mustAtoi(rec[1], "group_memberships.user_id")
		role := rec[2]

		if err := session.
			Query("INSERT INTO group_memberships (user_id, group_id, role) VALUES (?, ?, ?)", userID, groupID, role).
			WithContext(ctx).
			Exec(); err != nil {
			log.Fatalf("[scylladb_1] group_memberships: insert failed: %v", err)
		}
		count++

		// role is currently always "member"
		s, ok := groupMembers[groupID]
		if !ok {
			s = make(intSet)
			groupMembers[groupID] = s
		}
		s.add(userID)
	}

	log.Printf("[scylladb_1] group_memberships: inserted %d rows", count)
	return groupMembers
}

// =========================
// Load resources
// =========================
//
// resources.csv: resource_id,org_id
//
// Builds:
//
//	resourceOrg[resourceID] -> orgID
func loadResources(ctx context.Context, session *gocql.Session) map[int]int {
	r, f := openCSV("resources.csv")
	defer f.Close()

	// header: resource_id,org_id
	if _, err := r.Read(); err != nil {
		log.Fatalf("[scylladb_1] read resources header: %v", err)
	}

	resourceOrg := make(map[int]int)
	count := 0

	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[scylladb_1] resources: read row failed: %v", err)
		}
		if len(rec) < 2 {
			log.Fatalf("[scylladb_1] resources: invalid row: %#v", rec)
		}

		resID := mustAtoi(rec[0], "resources.resource_id")
		orgID := mustAtoi(rec[1], "resources.org_id")

		if err := session.
			Query("INSERT INTO resources (resource_id, org_id) VALUES (?, ?)", resID, orgID).
			WithContext(ctx).
			Exec(); err != nil {
			log.Fatalf("[scylladb_1] resources: insert failed: %v", err)
		}
		count++

		resourceOrg[resID] = orgID
	}

	log.Printf("[scylladb_1] resources: inserted %d rows", count)
	return resourceOrg
}

// =========================
// Load resource_acl
// =========================
//
// resource_acl.csv: resource_id,subject_type,subject_id,relation
//
// Writes into:
//
//	resource_acl_by_resource
//	resource_acl_by_subject
//
// Builds:
//
//	directUserManagers[resID] -> set of userID
//	directUserViewers[resID]  -> set of userID
//	groupManagers[resID]      -> set of groupID
//	groupViewers[resID]       -> set of groupID
func loadResourceACL(
	ctx context.Context,
	session *gocql.Session,
) (map[int]intSet, map[int]intSet, map[int]intSet, map[int]intSet) {
	r, f := openCSV("resource_acl.csv")
	defer f.Close()

	// header: resource_id,subject_type,subject_id,relation
	if _, err := r.Read(); err != nil {
		log.Fatalf("[scylladb_1] read resource_acl header: %v", err)
	}

	directUserManagers := make(map[int]intSet)
	directUserViewers := make(map[int]intSet)
	groupManagers := make(map[int]intSet)
	groupViewers := make(map[int]intSet)

	count := 0
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[scylladb_1] resource_acl: read row failed: %v", err)
		}
		if len(rec) < 4 {
			log.Fatalf("[scylladb_1] resource_acl: invalid row: %#v", rec)
		}

		resID := mustAtoi(rec[0], "resource_acl.resource_id")
		subjectType := rec[1]
		subjectID := mustAtoi(rec[2], "resource_acl.subject_id")
		relation := rec[3]

		// Insert into resource_acl_by_resource
		if err := session.
			Query(
				"INSERT INTO resource_acl_by_resource (resource_id, relation, subject_type, subject_id) VALUES (?, ?, ?, ?)",
				resID, relation, subjectType, subjectID,
			).
			WithContext(ctx).
			Exec(); err != nil {
			log.Fatalf("[scylladb_1] resource_acl_by_resource: insert failed: %v", err)
		}

		// Insert into resource_acl_by_subject
		if err := session.
			Query(
				"INSERT INTO resource_acl_by_subject (subject_type, subject_id, relation, resource_id) VALUES (?, ?, ?, ?)",
				subjectType, subjectID, relation, resID,
			).
			WithContext(ctx).
			Exec(); err != nil {
			log.Fatalf("[scylladb_1] resource_acl_by_subject: insert failed: %v", err)
		}

		count++

		switch subjectType {
		case "user":
			switch relation {
			case "manager":
				s, ok := directUserManagers[resID]
				if !ok {
					s = make(intSet)
					directUserManagers[resID] = s
				}
				s.add(subjectID)
			case "viewer":
				s, ok := directUserViewers[resID]
				if !ok {
					s = make(intSet)
					directUserViewers[resID] = s
				}
				s.add(subjectID)
			default:
				log.Fatalf("[scylladb_1] resource_acl: unknown relation for user: %q", relation)
			}

		case "group":
			switch relation {
			case "manager":
				s, ok := groupManagers[resID]
				if !ok {
					s = make(intSet)
					groupManagers[resID] = s
				}
				s.add(subjectID)
			case "viewer":
				s, ok := groupViewers[resID]
				if !ok {
					s = make(intSet)
					groupViewers[resID] = s
				}
				s.add(subjectID)
			default:
				log.Fatalf("[scylladb_1] resource_acl: unknown relation for group: %q", relation)
			}

		default:
			log.Fatalf("[scylladb_1] resource_acl: unknown subject_type: %q", subjectType)
		}
	}

	log.Printf("[scylladb_1] resource_acl: inserted %d rows", count)
	return directUserManagers, directUserViewers, groupManagers, groupViewers
}

// =========================
// Build user_resource_perms_*
// =========================

func buildUserResourcePerms(
	ctx context.Context,
	session *gocql.Session,
	resourceOrg map[int]int,
	orgAdmins map[int]intSet,
	orgMembers map[int]intSet,
	groupMembers map[int]intSet,
	directUserManagers map[int]intSet,
	directUserViewers map[int]intSet,
	groupManagers map[int]intSet,
	groupViewers map[int]intSet,
) {
	start := time.Now()
	totalPerms := 0

	log.Printf("[scylladb_1] Building user_resource_perms_by_user & _by_resource ...")

	for resID, orgID := range resourceOrg {
		manageUsers := make(intSet)
		viewUsers := make(intSet)

		// 1) direct manager users
		if s, ok := directUserManagers[resID]; ok {
			for u := range s {
				manageUsers.add(u)
			}
		}

		// 2) managers via groups
		if mgrGroups, ok := groupManagers[resID]; ok {
			for g := range mgrGroups {
				if members, ok := groupMembers[g]; ok {
					for u := range members {
						manageUsers.add(u)
					}
				}
			}
		}

		// 3) org admins
		if admins, ok := orgAdmins[orgID]; ok {
			for u := range admins {
				manageUsers.add(u)
			}
		}

		// 4) viewUsers starts as manageUsers
		for u := range manageUsers {
			viewUsers.add(u)
		}

		// 5) direct viewers
		if viewers, ok := directUserViewers[resID]; ok {
			for u := range viewers {
				viewUsers.add(u)
			}
		}

		// 6) viewers via groups
		if viewerGroups, ok := groupViewers[resID]; ok {
			for g := range viewerGroups {
				if members, ok := groupMembers[g]; ok {
					for u := range members {
						viewUsers.add(u)
					}
				}
			}
		}

		// 7) org members
		if members, ok := orgMembers[orgID]; ok {
			for u := range members {
				viewUsers.add(u)
			}
		}

		if len(viewUsers) == 0 {
			continue
		}

		// Insert all permissions for this resource.
		batchByUser := session.NewBatch(gocql.UnloggedBatch)
		batchByRes := session.NewBatch(gocql.UnloggedBatch)

		for u := range viewUsers {
			canManage := manageUsers.has(u)
			canView := true // by definition, users in viewUsers can view

			batchByUser.Query(
				"INSERT INTO user_resource_perms_by_user (user_id, resource_id, can_manage, can_view) VALUES (?, ?, ?, ?)",
				u, resID, canManage, canView,
			)
			batchByRes.Query(
				"INSERT INTO user_resource_perms_by_resource (resource_id, user_id, can_manage, can_view) VALUES (?, ?, ?, ?)",
				resID, u, canManage, canView,
			)

			totalPerms++
		}

		if len(batchByUser.Entries) > 0 {
			if err := session.ExecuteBatch(batchByUser); err != nil {
				log.Fatalf("[scylladb_1] ExecuteBatch user_resource_perms_by_user failed: %v", err)
			}
		}
		if len(batchByRes.Entries) > 0 {
			if err := session.ExecuteBatch(batchByRes); err != nil {
				log.Fatalf("[scylladb_1] ExecuteBatch user_resource_perms_by_resource failed: %v", err)
			}
		}
	}

	elapsed := time.Since(start).Truncate(time.Millisecond)
	log.Printf("[scylladb_1] Built user_resource_perms_*: %d user-resource rows in %s", totalPerms, elapsed)
}
